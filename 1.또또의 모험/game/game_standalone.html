<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë˜ë˜ì˜ ëª¨í—˜ (The Adventure of Toto)</title>
    <link rel="icon" type="image/png" href="assets/player/toto_idle.png">
    <style>
@font-face {
    font-family: 'PixelPowerline';
    src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background-color: #000;
    color: #fff;
    font-family: 'Press Start 2P', cursive, sans-serif;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

#game-container {
    position: relative;
    max-width: 100vw;
    max-height: 100vh;
    border: 4px solid #fff;
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
    image-rendering: pixelated;
    background-color: #0d1b2a;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}

.hidden {
    display: none !important;
}

#gameCanvas {
    /* JSê°€ ìŠ¤íƒ€ì¼ width/heightë¥¼ ì¡°ì ˆí•¨ */
    width: 100%;
    height: 100%;
    display: block;
}

/* ì¤‘ë³µëœ #gameCanvas ì œê±°ë¨ */

/* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ (í„°ì¹˜) */
#mobile-controls {
    display: none;
    position: absolute;
    bottom: 20px;
    left: 0;
    width: 100%;
    height: 200px;
    pointer-events: none;
    z-index: 2000;
}

.control-group {
    pointer-events: auto;
    position: absolute;
    bottom: 20px;
}

#d-pad {
    left: 40px;
    width: 180px;
    height: 180px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.1);
}

.d-btn {
    position: absolute;
    width: 60px;
    height: 60px;
    background: rgba(255, 255, 255, 0.15);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    transition: background 0.1s, transform 0.1s;
}

#up {
    top: 5px;
    left: 60px;
}

#down {
    bottom: 5px;
    left: 60px;
}

#left {
    top: 60px;
    left: 5px;
}

#right {
    top: 60px;
    right: 5px;
}

/* Center Indicator */
#d-pad::after {
    content: '';
    position: absolute;
    top: 75px;
    left: 75px;
    width: 30px;
    height: 30px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
}

#action-group {
    right: 40px;
    width: 200px;
    height: 120px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 30px;
}

.act-btn {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    color: white;
    border: 4px solid #fff;
    cursor: pointer;
    transition: transform 0.1s;
    user-select: none;
}

#btn-shot {
    width: 100px;
    height: 100px;
    background: rgba(255, 0, 0, 0.6);
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
}

#btn-bomb {
    background: rgba(0, 150, 255, 0.6);
    box-shadow: 0 0 20px rgba(0, 150, 255, 0.4);
}

.d-btn:active,
.act-btn:active {
    background: rgba(255, 255, 255, 0.8) !important;
    transform: scale(1.15);
}

/* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ë…¸ì¶œ ì¡°ê±´ ì™„í™”: í˜„ëŒ€ì  ëª¨ë°”ì¼ ê¸°ê¸° í˜¸í™˜ì„± ê°•í™” */
@media (pointer: coarse) {
    #mobile-controls {
        display: block;
    }
}

#ui-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

#hud {
    position: absolute;
    top: 20px;
    left: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(5px);
    border-left: 4px solid #ffcc00;
    border-radius: 4px;
    font-family: inherit;
    z-index: 1000;
    pointer-events: none;
}

.score-container {
    font-size: 14px;
    color: #aaa;
    margin-bottom: -5px;
}

#score {
    color: #ffeb3b;
    font-size: 28px;
    font-weight: 900;
    text-shadow: 2px 2px 0 #333;
}

.life-container,
.bomb-container {
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 10px;
}

#lives {
    color: #ff5252;
    letter-spacing: 2px;
    text-shadow: 1px 1px 0 #000;
}

#bombs {
    color: #00e5ff;
    letter-spacing: 2px;
}

#dialogue-box {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 800px;
    height: 140px;
    background: rgba(0, 0, 0, 0.9);
    border: 4px solid #ffcc00;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    display: flex;
    padding: 20px;
    z-index: 1000;
    pointer-events: auto;
    /* Allow clicking the box to advance dialogue */
    transition: opacity 0.3s, transform 0.3s;
}

#dialogue-box.hidden {
    opacity: 0;
    transform: translate(-50%, 20px);
}

.character-name {
    color: #ffcc00;
    font-weight: 900;
    font-size: 20px;
    margin-bottom: 12px;
}

.text {
    font-size: 18px;
    line-height: 1.6;
    color: #fff;
}

/* ì‹œì‘ í™”ë©´ */
/* ì‹œì‘ í™”ë©´ */
#start-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url('assets/background/bg_start.png');
    background-size: cover;
    background-position: center;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    /* ìƒë‹¨ ê¸°ì¤€ ì •ë ¬ */
    align-items: center;
    z-index: 200;
}

@font-face {
    font-family: 'Jalnan';
    src: url('https://cdn.jsdelivr.net/gh/jabont/Jalnan/Jalnan.woff') format('woff');
    font-weight: normal;
    font-style: normal;
}

#start-screen h1.title {
    font-family: 'Jalnan', sans-serif;
    font-size: 90px;
    font-weight: normal;
    background: linear-gradient(to bottom, #FFFB00 0%, #FFD54F 50%, #FFA000 100%);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    text-transform: uppercase;
    filter: drop-shadow(2px 2px 0px #3E2723) drop-shadow(4px 4px 0px #3E2723) drop-shadow(0px 0px 20px rgba(255, 213, 79, 0.5));
    margin-bottom: 0;
    margin-top: 150px;
    /* ë¬´ì§€ê°œ ìœ„ì¹˜ë¡œ í•˜í–¥ ì¡°ì • */
    transform: perspective(500px) rotateX(10deg);
    animation: titleFloat 3s infinite ease-in-out;
}

#start-screen .start-message {
    font-size: 24px;
    color: #ffffff;
    text-shadow: 2px 2px 0 #000;
    animation: blink 0.8s infinite;
    background: rgba(0, 0, 0, 0.4);
    padding: 10px 30px;
    border-radius: 30px;
    margin-top: 280px;
    /* ìºë¦­í„° ì•„ë˜ë¡œ ë” ë‚´ë¦¼ */
    margin-bottom: 20px;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.instruction-message {
    font-size: 14px;
    color: #e0e0e0;
    text-shadow: 1px 1px #000;
    background: rgba(0, 0, 0, 0.3);
    padding: 5px 15px;
    border-radius: 10px;
}

.company-credit {
    font-size: 10px;
    color: #cfd8dc;
    /* ë” ë°ì€ ìƒ‰ìœ¼ë¡œ êµì²´ */
    margin-top: 15px;
    text-transform: uppercase;
    letter-spacing: 1px;
    opacity: 1;
    /* íˆ¬ëª…ë„ ì œê±° */
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    /* ê°€ë…ì„±ì„ ìœ„í•œ ê·¸ë¦¼ì ì¶”ê°€ */
}



@keyframes titleFloat {

    0%,
    100% {
        transform: translateY(0);
    }

    50% {
        transform: translateY(-10px);
    }
}

@keyframes blink {

    0%,
    100% {
        opacity: 1;
    }

    50% {
        opacity: 0;
    }
}

.hidden {
    display: none !important;
}

/* [New] Orientation Warning Styles */
#orientation-warning {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #0d1b2a;
    color: #fff;
    z-index: 99999;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-family: 'Malgun Gothic', sans-serif;
}

.rotate-icon {
    font-size: 80px;
    margin-bottom: 20px;
    animation: rotateDevice 2s infinite ease-in-out;
}

.warning-text {
    font-size: 24px;
    font-weight: bold;
    color: #ffcc00;
    margin-bottom: 10px;
}

.sub-text {
    font-size: 16px;
    color: #aaa;
}

@keyframes rotateDevice {
    0% {
        transform: rotate(0deg);
    }

    50% {
        transform: rotate(-90deg);
    }

    100% {
        transform: rotate(0deg);
    }
}

/* [Dev Tools] CSS - Non-blocking UI */
#dev-tools {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 9000;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 5px;
    pointer-events: none;
}

#dev-toggle {
    pointer-events: auto;
    background: rgba(0, 0, 0, 0.6);
    color: #ffcc00;
    border: 1px solid #ffcc00;
    padding: 5px 10px;
    font-size: 10px;
    font-weight: bold;
    cursor: pointer;
    border-radius: 4px;
}

#dev-panel {
    pointer-events: auto;
    display: flex;
    flex-direction: column;
    gap: 4px;
    background: rgba(0, 0, 0, 0.8);
    padding: 10px;
    border-radius: 8px;
    border: 1px solid #444;
}

#dev-panel button {
    padding: 8px;
    color: white;
    border: none;
    font-size: 10px;
    font-weight: bold;
    cursor: pointer;
    border-radius: 4px;
    text-align: left;
    white-space: nowrap;
}

/* Orientation Warning */
@media screen and (orientation: portrait) and (max-width: 1024px) {
    #orientation-warning {
        display: flex;
    }

    #game-container {
        display: none;
    }
}
</style>
    <script>
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            const errDiv = document.createElement('div');
            errDiv.style.position = 'fixed';
            errDiv.style.top = '0';
            errDiv.style.left = '0';
            errDiv.style.width = '100%';
            errDiv.style.background = 'red';
            errDiv.style.color = 'white';
            errDiv.style.zIndex = '100000';
            errDiv.style.padding = '10px';
            errDiv.style.fontFamily = 'monospace';
            errDiv.innerText = 'ERROR: ' + msg + ' at ' + url + ':' + lineNo;
            document.body.appendChild(errDiv);
            return false;
        };
    </script>
</head>

<body>
    <!-- [New] Orientation Warning for Mobile -->
    <div id="orientation-warning">
        <div class="rotate-icon">ğŸ”„</div>
        <div class="warning-text">PLEASE ROTATE TO LANDSCAPE</div>
        <div class="sub-text">ê°€ë¡œ ëª¨ë“œë¡œ íšŒì „í•˜ì—¬ ê²Œì„ì„ ì¦ê²¨ì£¼ì„¸ìš”</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="start-screen">
            <h1 class="title">ë˜ë˜ì˜ ëª¨í—˜</h1>
            <div class="start-message">CLICK TO START</div>
            <div class="instruction-message">Space: Shoot | X: Bomb | Arrows: Move</div>
            <div class="company-credit">Provided by Mabu Interactive</div>
        </div>
        <div id="ui-layer" class="hidden">
            <div id="hud" class="hidden">
                <div class="score-container">SCORE: <span id="score">000000</span></div>
                <div class="life-container">LIFE: <span id="lives">â˜…â˜…â˜…</span></div>
                <div class="bomb-container">BOMB: <span id="bombs">ğŸ’£ğŸ’£ğŸ’£</span></div>
            </div>
            <div id="dialogue-box" class="hidden">
                <div class="character-portrait"></div>
                <div class="dialogue-content">
                    <div class="character-name">ë˜ë˜</div>
                    <div class="text">ì˜¤ëŠ˜ë”°ë¼ ìˆ²ì´ ë„ˆë¬´ ì¡°ìš©í•œ ê±¸?</div>
                </div>
            </div>
            <!-- ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ (í„°ì¹˜ìš©) -->
            <div id="mobile-controls">
                <div id="d-pad" class="control-group">
                    <div id="up" class="d-btn" data-key="ArrowUp"></div>
                    <div id="down" class="d-btn" data-key="ArrowDown"></div>
                    <div id="left" class="d-btn" data-key="ArrowLeft"></div>
                    <div id="right" class="d-btn" data-key="ArrowRight"></div>
                </div>
                <div id="action-group" class="control-group">
                    <div id="btn-bomb" class="act-btn" data-key="KeyX">ğŸ’£</div>
                    <div id="btn-shot" class="act-btn" data-key="Space">ğŸ”¥</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Removed duplicate script tag -->
    <!--  This was causing issues -->
<script>

/* --- constants.js --- */
// ê²Œì„ ì‹œìŠ¤í…œ ìƒìˆ˜ ë° ì„¤ì •
const CONFIG = {
    SCREEN_WIDTH: 1280,
    SCREEN_HEIGHT: 720,
    PLAYER_SPEED: 9.0,
    FRICTION: 0.9,
    FPS: 60,
    GAME_SPEED: 1.0
};
const CHARACTERS = [
    { id: 'toto', name: 'ë˜ë˜', speed: 6.8, power: 'ì¼ë°˜', range: 'ê´‘ì—­', shotDelay: 200, color: '#ffcc00' },
    { id: 'lulu', name: 'ë£¨ë£¨', speed: 9.5, power: 'ì¼ë°˜', range: 'ì¢ìŒ', shotDelay: 130, color: '#F06292' },
    { id: 'kaka', name: 'ì¹´ì¹´', speed: 5.2, power: 'ê°•ë ¥', range: 'ì¤‘ì•™', shotDelay: 350, color: '#4E342E' },
    { id: 'momo', name: 'ëª¨ëª¨', speed: 5.8, power: 'ì¼ë°˜', range: 'ê´‘ì—­', shotDelay: 220, color: '#D32F2F' },
    { id: 'pipi', name: 'í”¼í”¼', speed: 7.5, power: 'ì¼ë°˜', range: 'ìœ ë„', shotDelay: 180, color: '#2E7D32' }
];
const ENEMY_TYPES = {
    SCOUT_WASP: 0,
    DANCING_BUTTERFLY: 1,
    BEETLE: 2,
    DRONE: 3,
    GHOST: 4,
    SLIME: 5,
    BOSS_BULLET: 99
};
const STAGE_ENEMIES = {
    1: [ENEMY_TYPES.SCOUT_WASP, ENEMY_TYPES.DANCING_BUTTERFLY],
    2: [ENEMY_TYPES.SCOUT_WASP, ENEMY_TYPES.BEETLE],
    3: [ENEMY_TYPES.DANCING_BUTTERFLY, ENEMY_TYPES.BEETLE],
    4: [ENEMY_TYPES.DRONE],
    5: [ENEMY_TYPES.GHOST],
    6: [ENEMY_TYPES.BEETLE],
    7: [ENEMY_TYPES.DRONE, ENEMY_TYPES.SLIME],
    8: [ENEMY_TYPES.SLIME, ENEMY_TYPES.SCOUT_WASP],
    9: [ENEMY_TYPES.DRONE, ENEMY_TYPES.SCOUT_WASP],
    10: [ENEMY_TYPES.GHOST, ENEMY_TYPES.DRONE]
};
const BOSS_DATA = {
    1: { type: 1, name: "General Buzz", width: 300, height: 250, hp: 100, maxHp: 100 },
    2: { type: 2, name: "Queen Arachne", width: 350, height: 300, hp: 400, maxHp: 400 },
    3: { type: 3, name: "Metal Orochi", width: 450, height: 220, hp: 800, maxHp: 800 },
    4: { type: 4, name: "Storm Falcon", width: 300, height: 240, hp: 1000, maxHp: 1000 },
    5: { type: 5, name: "Phantom Moth", width: 400, height: 280, hp: 1200, maxHp: 1200 },
    6: { type: 6, name: "Flame Salamander", width: 500, height: 250, hp: 1600, maxHp: 1600 },
    7: { type: 7, name: "Junk Amalgam", width: 400, height: 400, hp: 2000, maxHp: 2000 },
    8: { type: 8, name: "Toxic Chimera", width: 450, height: 320, hp: 2400, maxHp: 2400 },
    9: { type: 9, name: "Sky Fortress Core", width: 600, height: 600, hp: 3000, maxHp: 3000 },
    10: { type: 10, name: "Emperor V", width: 350, height: 480, hp: 3200, maxHp: 3200 }
};

// ìŠ¤í…Œì´ì§€ë³„ ëŒ€í™” ë°ì´í„°
const STAGE_DIALOGUES = {
    1: [
        { name: "ë˜ë˜", text: "ë“œë””ì–´ ëª¨í—˜ì˜ ì‹œì‘ì´ì•¼! í‰í™”ë¡œìš´ ìˆ²ì„ ì§€ì¼œë‚´ê² ì–´.", side: "left" },
        { name: "ìš”ì •", text: "ë˜ë˜, ì¡°ì‹¬í•´! ë§ë²Œ ë¶€ëŒ€ê°€ ë‚˜íƒ€ë‚¬ë‹¤ëŠ” ë³´ê³ ì•¼.", side: "right" }
    ],
    2: [
        { name: "ë˜ë˜", text: "ë°¤ì´ ë˜ë‹ˆ ê³µê¸°ê°€ ì°¨ê°€ì›Œì¡Œì–´. ë” ìœ„í—˜í•œ ë…€ì„ë“¤ì´ ì˜¤ê² êµ°.", side: "left" },
        { name: "ìš”ì •", text: "ì ë“¤ì˜ ê³µê²©ì´ ë” ê±°ì„¸ì§ˆ ê±°ì•¼. ì§‘ì¤‘í•´!", side: "right" }
    ],
    3: [
        { name: "ë˜ë˜", text: "ì´ ë¶‰ì€ í™©í˜¼... ë³´ìŠ¤ê°€ ê°€ê¹Œì´ ìˆëŠ” ê²ƒ ê°™ì•„.", side: "left" },
        { name: "ìš”ì •", text: "ì—¬ê¸°ì„œ ë°€ë¦¬ë©´ ëì¥ì´ì•¼. ë‚´ê°€ ì˜†ì—ì„œ ì§€ì›í• ê²Œ!", side: "right" }
    ],
    4: [ // Stage 4: Storm Falcon
        { name: "ë˜ë˜", text: "ë°”ëŒì´ ê±°ì„¸ì§€ê³  ìˆì–´! ì¤‘ì‹¬ ì¡ê¸°ê°€ í˜ë“¤ì–´.", side: "left" },
        { name: "ìš”ì •", text: "í˜‘ê³¡ì˜ ì£¼ì¸ì´ ë‚˜íƒ€ë‚  ì‹œê°„ì´ì•¼. ì†ë„ì— ì£¼ì˜í•´!", side: "right" }
    ],
    5: [ // Stage 5: Phantom Moth
        { name: "ë˜ë˜", text: "ì•ì´ ì˜ ì•ˆ ë³´ì—¬... ë­”ê°€ íë¦¿í•œë°.", side: "left" },
        { name: "ìš”ì •", text: "í™˜ê° ê°€ë£¨ì•¼! ì§„ì§œì™€ ê°€ì§œë¥¼ êµ¬ë³„í•´ì•¼ í•´!", side: "right" }
    ],
    6: [ // Stage 6: Flame Salamander
        { name: "ë˜ë˜", text: "ì•— ëœ¨ê±°! ìˆ²ì´ ë¶ˆíƒ€ê³  ìˆì–´!", side: "left" },
        { name: "ìš”ì •", text: "ë¶ˆê¸¸ì„ ëš«ê³  ì›í‰ì„ ì œê±°í•´ì•¼ í•´. ì‹œê°„ì´ ì—†ì–´!", side: "right" }
    ],
    7: [ // Stage 7: Junk Amalgam
        { name: "ë˜ë˜", text: "ì´ ê³ ì² ë©ì–´ë¦¬ë“¤ì€ ë­ì§€? ì“°ë ˆê¸°ì¥ì¸ê°€?", side: "left" },
        { name: "ìš”ì •", text: "ë†ˆë“¤ì´ ë²„ë ¤ì§„ ê¸°ê³„ë“¤ì„ í¡ìˆ˜í•˜ê³  ìˆì–´. í•µì„ ë…¸ë ¤!", side: "right" }
    ],
    8: [ // Stage 8: Toxic Chimera
        { name: "ë˜ë˜", text: "ìš°ì›©, ëƒ„ìƒˆê°€ ì§€ë…í•´! ìˆ¨ì„ ëª» ì‰¬ê² ì–´.", side: "left" },
        { name: "ìš”ì •", text: "ë°©ë…ë©´ ì¨! ë†ˆì´ ë…ê°€ìŠ¤ë¥¼ ë¿œê³  ìˆì–´!", side: "right" }
    ],
    9: [ // Stage 9: Sky Fortress Core
        { name: "ë˜ë˜", text: "ì €ê²Œ ì ë“¤ì˜ ë³¸ê±°ì§€ì¸ê°€? ì—„ì²­ë‚˜ê²Œ í¬ì–ì•„!", side: "left" },
        { name: "ìš”ì •", text: "ìµœì¢… ë°©ì–´ì„ ì´ì•¼. ì €ê±¸ ëš«ì–´ì•¼ í™©ì œë¥¼ ë§Œë‚  ìˆ˜ ìˆì–´!", side: "right" }
    ],
    10: [ // Stage 10: Emperor "V"
        { name: "Emperor V", text: "ì—¬ê¸°ê¹Œì§€ ì˜¤ë‹¤ë‹ˆ. ê°€ìƒí•˜êµ¬ë‚˜, ì‘ì€ ë²Œë ˆì—¬.", side: "right" },
        { name: "ë˜ë˜", text: "ìˆ²ì„ ì›ë˜ëŒ€ë¡œ ëŒë ¤ë†”! ë„¤ ì•¼ë§ì€ ëì´ë‹¤!", side: "left" },
        { name: "Emperor V", text: "ë‚˜ì˜ ìœ„ëŒ€í•œ ê³„íšì„ ì´í•´í•˜ì§€ ëª»í•˜ëŠ”êµ°. ì‚¬ë¼ì ¸ë¼!", side: "right" }
    ]
};

/* --- state.js --- */
const state = {
    score: 0,
    lives: 3,
    keys: {},
    player: {
        x: 100,
        y: 300,
        vx: 0,
        vy: 0,
        width: 148,
        height: 148,
        color: '#ffcc00',
        strokeColor: '#ffffff',
        lastShotTime: 0,
        shotDelay: 200,
        invincibleTime: 0,
        powerLevel: 1,
        maxPowerLevel: 5,
        bombCount: 3,
        chargeValue: 0,
        maxChargeValue: 60,
        id: 'toto'
    },
    enemies: [],
    bullets: [],
    items: [],
    bombs: [],
    particles: [],
    enemyBullets: [],
    boss: null,
    bgOffset: 0,
    gameActive: false,
    gameOver: false,
    isSelectingCharacter: false,
    selectedCharIndex: 0,
    lastSpawnTime: 0,
    spawnInterval: 1500,
    currentStage: 1,
    stageCleared: false,
    bossSpawnedInStage: false,
    stageTransitionTimer: 0,
    stageStartScore: 0,
    isDialogueActive: false,
    dialogueIndex: 0,
    isBranching: false,
    selectedBranch: 'day',
    isWorldMapActive: false,
    isWorldMapReady: false,
    worldMapTimer: 0,
    mapProgress: 0,
    isContinuing: false
};
function resetState() {
    state.score = 0;
    state.lives = 3;
    state.keys = {};

    // Reset Player
    state.player.x = 100;
    state.player.y = 300;
    state.player.vx = 0;
    state.player.vy = 0;
    state.player.lastShotTime = 0;
    state.player.invincible = false;
    state.player.invincibleTime = 0;
    state.player.powerLevel = 1;
    state.player.bombCount = 3;
    state.player.chargeValue = 0;

    // Reset Game Entities
    state.enemies = [];
    state.bullets = [];
    state.items = [];
    state.bombs = [];
    state.particles = [];
    state.enemyBullets = [];
    state.boss = null;

    // Reset Progress Flags
    state.bgOffset = 0;
    state.gameActive = false;
    state.gameOver = false;
    state.isTitleScreen = true;
    state.isSelectingCharacter = false;
    state.currentStage = 1;
    state.stageCleared = false;
    state.bossSpawnedInStage = false;
    state.stageTransitionTimer = 0;
    state.stageStartScore = 0;
    state.isDialogueActive = false;
    state.isWorldMapActive = false;
    state.isWorldMapReady = false;
    state.isContinuing = false;
}

// Expose state for cheats/debugging
window.state = state;

/* --- assets.js --- */

// Hansooni's High-Fidelity Asset Library (Vector/SVG Edition)
// Bypassing server lag to deliver project assets immediately.
const ASSETS = {
    toto: `data:image/svg+xml;base64,${btoa(`
        <svg width="64" height="64" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
            <!-- Wings (Animated Shimmer) -->
            <ellipse cx="20" cy="25" rx="15" ry="8" fill="rgba(200, 240, 255, 0.7)" transform="rotate(-30 20 25)" />
            <ellipse cx="20" cy="35" rx="15" ry="8" fill="rgba(200, 240, 255, 0.5)" transform="rotate(30 20 35)" />
            <!-- Bee Body -->
            <ellipse cx="35" cy="32" rx="22" ry="16" fill="#FFEB3B" stroke="#000" stroke-width="2" />
            <!-- Stripes -->
            <path d="M28 18 Q30 32 28 46" fill="transparent" stroke="#212121" stroke-width="6" />
            <path d="M38 18 Q40 32 38 46" fill="transparent" stroke="#212121" stroke-width="6" />
            <!-- Head & Glasses -->
            <circle cx="50" cy="32" r="12" fill="#FFEB3B" stroke="#000" stroke-width="1.5" />
            <circle cx="54" cy="28" r="5" fill="none" stroke="#212121" stroke-width="2" />
            <circle cx="54" cy="28" r="4" fill="#00E5FF" opacity="0.6" />
            <rect x="58" y="27" width="4" height="2" fill="#212121" />
            <!-- Eye -->
            <circle cx="48" cy="28" r="2" fill="#000" />
        </svg>
    `)}`,

    boss_buzz: `data:image/svg+xml;base64,${btoa(`
        <svg width="128" height="128" viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="gold" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#FFD700" />
                    <stop offset="50%" style="stop-color:#FF8C00" />
                    <stop offset="100%" style="stop-color:#B8860B" />
                </linearGradient>
            </defs>
            <!-- Heavy Wings -->
            <path d="M40 40 L10 10 L40 30 Z" fill="rgba(255,100,100,0.4)" />
            <path d="M40 88 L10 118 L40 98 Z" fill="rgba(255,100,100,0.4)" />
            <!-- Heavy Armor Body -->
            <rect x="30" y="30" width="80" height="68" rx="8" fill="url(#gold)" stroke="#3e2723" stroke-width="4" />
            <!-- Gatling Gun -->
            <rect x="0" y="55" width="45" height="18" fill="#455a64" stroke="#263238" stroke-width="2" />
            <rect x="0" y="58" width="45" height="4" fill="#607d8b" />
            <!-- Glowing Eye -->
            <circle cx="100" cy="50" r="14" fill="#000" />
            <circle cx="105" cy="48" r="6" fill="#FF1744">
                <animate attributeName="opacity" values="1;0.4;1" dur="0.5s" repeatCount="indefinite" />
            </circle>
            <!-- Vent Pipes -->
            <rect x="110" y="40" width="10" height="4" fill="#212121" />
            <rect x="110" y="84" width="10" height="4" fill="#212121" />
        </svg>
    `)}`,

    scout_wasp: `data:image/svg+xml;base64,${btoa(`
        <svg width="48" height="48" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
            <ellipse cx="24" cy="24" rx="18" ry="12" fill="#FFA726" stroke="#000" stroke-width="2" />
            <rect x="18" y="14" width="4" height="20" fill="#212121" />
            <!-- Scouter Eye -->
            <rect x="34" y="16" width="10" height="10" fill="#263238" />
            <rect x="36" y="18" width="6" height="6" fill="#F44336">
                <animate attributeName="opacity" values="1;0.2;1" dur="1s" repeatCount="indefinite" />
            </rect>
            <!-- Wings -->
            <path d="M20 15 L5 0 L15 10 Z" fill="rgba(200,200,255,0.5)" />
        </svg>
    `)}`
};

// Background Image Assets
const BACKGROUND_IMAGES = {};

// Stage 1 Assets (New Stage 1 Background)
BACKGROUND_IMAGES.s1_layer01 = new Image(); BACKGROUND_IMAGES.s1_layer01.src = 'assets/background/bg_stage1_layer01.png';
BACKGROUND_IMAGES.s1_layer02 = new Image(); BACKGROUND_IMAGES.s1_layer02.src = 'assets/background/bg_stage1_layer02.png';
BACKGROUND_IMAGES.s1_layer03 = new Image(); BACKGROUND_IMAGES.s1_layer03.src = 'assets/background/bg_stage1_layer03.png';
BACKGROUND_IMAGES.s1_layer04 = new Image(); BACKGROUND_IMAGES.s1_layer04.src = 'assets/background/bg_stage1_layer04.png';
BACKGROUND_IMAGES.s1_layer05 = new Image(); BACKGROUND_IMAGES.s1_layer05.src = 'assets/background/bg_stage1_layer05.png';

// Stage 2 Assets (3 Layers)
BACKGROUND_IMAGES.s2_layer01 = new Image(); BACKGROUND_IMAGES.s2_layer01.src = 'assets/background/bg_stage2_layer01.png';
BACKGROUND_IMAGES.s2_layer02 = new Image(); BACKGROUND_IMAGES.s2_layer02.src = 'assets/background/bg_stage2_layer02.png';
BACKGROUND_IMAGES.s2_layer03 = new Image(); BACKGROUND_IMAGES.s2_layer03.src = 'assets/background/bg_stage2_layer03.png';

// Stage 3 Assets (Sunset)
BACKGROUND_IMAGES.s3_layer01 = new Image(); BACKGROUND_IMAGES.s3_layer01.src = 'assets/background/bg_stage3_layer01.png';
BACKGROUND_IMAGES.s3_layer02 = new Image(); BACKGROUND_IMAGES.s3_layer02.src = 'assets/background/bg_stage3_layer02.png';
BACKGROUND_IMAGES.s3_layer03 = new Image(); BACKGROUND_IMAGES.s3_layer03.src = 'assets/background/bg_stage3_layer03.png';
BACKGROUND_IMAGES.s3_layer04 = new Image(); BACKGROUND_IMAGES.s3_layer04.src = 'assets/background/bg_stage3_layer04.png';

// Stage 4 Assets
BACKGROUND_IMAGES.s4_layer01 = new Image(); BACKGROUND_IMAGES.s4_layer01.src = 'assets/background/bg_stage4_layer01.png';
BACKGROUND_IMAGES.s4_layer02 = new Image(); BACKGROUND_IMAGES.s4_layer02.src = 'assets/background/bg_stage4_layer02.png';
BACKGROUND_IMAGES.s4_layer03 = new Image(); BACKGROUND_IMAGES.s4_layer03.src = 'assets/background/bg_stage4_layer03.png';

BACKGROUND_IMAGES.bgStart = new Image();
BACKGROUND_IMAGES.bgStart.src = 'assets/background/bg_start.png';
BACKGROUND_IMAGES.bgCharSelect = new Image();
BACKGROUND_IMAGES.bgCharSelect.src = 'assets/background/bg_character_select.png';

// Player Character Image Assets
const PLAYER_IMAGES = {
    ch_player1: new Image(),
    ch_player2: new Image(),
    ch_player3: new Image(),
    ch_player4: new Image(),
    ch_player5: new Image()
};

PLAYER_IMAGES.ch_player1.src = 'assets/ch_player1.png';
PLAYER_IMAGES.ch_player2.src = 'assets/ch_player2.png';
PLAYER_IMAGES.ch_player3.src = 'assets/ch_player3.png';
PLAYER_IMAGES.ch_player4.src = 'assets/ch_player4.png';
PLAYER_IMAGES.ch_player5.src = 'assets/ch_player5.png';

// Global Asset Loader
async function loadAllAssets() {
    const images = [
        ...Object.values(BACKGROUND_IMAGES),
        ...Object.values(PLAYER_IMAGES)
    ];

    const loadPromises = images.map(img => {
        return new Promise((resolve) => {
            if (img.complete) resolve();
            img.onload = resolve;
            img.onerror = resolve; // Continue even if some fail
        });
    });

    await Promise.all(loadPromises);
    console.log("âœ… All assets processed (some may have failed but loop continues)");
}

/* --- sound.js --- */
class SoundEngine {
    constructor() {
        this.ctx = null;
        this.isEnabled = false;
        this.reverbNode = null;
        this.bgmLoop = null;
        this.currentBgmType = null;
        this.beatCount = 0;
        this.masterGain = null;
        this.assets = {};
        this.bgmSource = null;
    }

    async init() {
        if (!this.ctx) {
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error("AudioContext not supported", e);
                return;
            }
        }
        if (this.ctx.state === 'suspended') await this.ctx.resume();

        // Master Gain
        this.masterGain = this.ctx.createGain();
        this.masterGain.connect(this.ctx.destination);

        // Unlock
        const b = this.ctx.createBuffer(1, 1, 22050);
        const s = this.ctx.createBufferSource();
        s.buffer = b; s.connect(this.masterGain); s.start(0);

        this.isEnabled = true;
        this.reverbNode = await this.createReverb();

        await this.loadAssets();
        console.log("ğŸ”Š Mabu Sound Engine R&D Initialized");
    }

    async loadAssets() {
        const fileMap = {
            'shot_toto': 'sfx_shot_toto.mp3',
            'shot_lulu': 'sfx_shot_lulu.mp3',
            'shot_kaka': 'sfx_shot_kaka.mp3',
            'shot_pipi': 'sfx_shot_pipi.mp3',
            'shot_momo': 'sfx_shot_momo.mp3',
            'charge_toto': 'sfx_charge_toto.mp3',
            'charge_lulu': 'sfx_charge_lulu.mp3',
            'charge_kaka': 'sfx_charge_kaka.mp3',
            'charge_pipi': 'sfx_charge_pipi.mp3',
            'charge_momo': 'sfx_charge_momo.mp3',
            'explosion': 'sfx_explosion.mp3',
            'item_get': 'sfx_item_get.mp3',
            'select': 'sfx_select.mp3',
            'confirm': 'sfx_confirm.mp3',
            'game_start': 'sfx_game_start.mp3',
            'bgm_start': 'bgm_start.mp3',
            'bgm_stage_low': 'bgm_stage_low.mp3',
            'bgm_stage_mid': 'bgm_stage_mid.mp3',
            'bgm_stage_high': 'bgm_stage_high.mp3',
            'bgm_ending': 'bgm_ending.mp3'
        };

        const promises = Object.entries(fileMap).map(async ([key, filename]) => {
            try {
                const res = await fetch(`game/assets/sound/${filename}`);
                if (!res.ok) return; // Silent fail for missing files
                const arrayBuffer = await res.arrayBuffer();
                const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                this.assets[key] = audioBuffer;
            } catch (e) {
                // console.warn(`Sound file not found: ${filename}`);
            }
        });
        await Promise.all(promises);
    }

    playBuffer(buffer, volume = 0.5, loop = false) {
        if (!buffer) return null;
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = loop;
        const gain = this.ctx.createGain();
        gain.gain.value = volume;
        source.connect(gain);
        gain.connect(this.masterGain);
        source.start();
        return source;
    }

    async createReverb() {
        const duration = 2, decay = 2, rate = this.ctx.sampleRate, length = rate * duration;
        const impulse = this.ctx.createBuffer(2, length, rate);
        const left = impulse.getChannelData(0), right = impulse.getChannelData(1);
        for (let i = 0; i < length; i++) {
            const n = i / length;
            left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
            right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
        }
        const convolver = this.ctx.createConvolver();
        convolver.buffer = impulse;
        return convolver;
    }

    // --- SFX Section ---
    playShot(charId = 'toto') {
        if (!this.isEnabled) return;
        if (this.assets[`shot_${charId}`]) return this.playBuffer(this.assets[`shot_${charId}`]);

        const t = this.ctx.currentTime;

        switch (charId) {
            case 'lulu': // Laser - High pitch rapid sweep
                {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(1200, t);
                    osc.frequency.exponentialRampToValueAtTime(300, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(); osc.stop(t + 0.1);
                }
                break;
            case 'kaka': // Heavy - Low pitch square
                {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(300, t);
                    osc.frequency.exponentialRampToValueAtTime(50, t + 0.15);
                    gain.gain.setValueAtTime(0.15, t); // Slightly louder
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(); osc.stop(t + 0.15);
                }
                break;
            case 'pipi': // Sonic/Wave - Modulated
                {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, t);
                    osc.frequency.linearRampToValueAtTime(800, t + 0.05);
                    osc.frequency.linearRampToValueAtTime(400, t + 0.15);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.15);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(); osc.stop(t + 0.15);
                }
                break;
            case 'momo': // Heart/Magic - Bell-like upward chirp
                {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(900, t);
                    osc.frequency.exponentialRampToValueAtTime(1500, t + 0.05);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(); osc.stop(t + 0.15);
                }
                break;
            case 'toto':
            default: // Classic pew
                {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(880, t);
                    osc.frequency.exponentialRampToValueAtTime(110, t + 0.15);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(); osc.stop(t + 0.15);
                }
                break;
        }
    }

    playChargeShot(charId) {
        if (!this.isEnabled) return;
        if (this.assets[`charge_${charId}`]) return this.playBuffer(this.assets[`charge_${charId}`]);

        const t = this.ctx.currentTime;

        switch (charId) {
            case 'toto': // Bit Bee Swarm (High-tech chirps)
                [880, 1100, 1320].forEach((f, i) => {
                    this.genNote(f, 0.1, 'square', 0.1, this.masterGain);
                    setTimeout(() => this.genNote(f * 1.5, 0.1, 'square', 0.1, this.masterGain), 50 + i * 30);
                });
                break;
            case 'lulu': // Prism Laser (Long energy sweep)
                {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(400, t);
                    osc.frequency.linearRampToValueAtTime(100, t + 1.0); // Power down
                    gain.gain.setValueAtTime(0.2, t);
                    gain.gain.linearRampToValueAtTime(0, t + 1.0);

                    // Add modulation
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = 50;
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = 200;
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    lfo.start(); lfo.stop(t + 1.0);

                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(); osc.stop(t + 1.0);
                }
                break;
            case 'kaka': // Meteor (Giant explosion/rumble)
                {
                    // Noise buffer
                    const bufferSize = this.ctx.sampleRate * 1.5; // 1.5 sec
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                    const noise = this.ctx.createBufferSource();
                    noise.buffer = buffer;
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(500, t);
                    filter.frequency.exponentialRampToValueAtTime(10, t + 1.5);
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.5, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 1.5);

                    noise.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
                    noise.start();
                }
                break;
            case 'momo': // Love Bomb (Magical Twinkle)
                [523, 659, 784, 1046, 1318, 1568].forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = f;
                    gain.gain.setValueAtTime(0, t + i * 0.05);
                    gain.gain.linearRampToValueAtTime(0.1, t + i * 0.05 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.05 + 0.3);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(t + i * 0.05); osc.stop(t + i * 0.05 + 0.3);
                });
                break;
            case 'pipi': // Sonic Boom (Whoosh)
                {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine'; // or triangle
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.exponentialRampToValueAtTime(800, t + 0.2); // Up
                    osc.frequency.exponentialRampToValueAtTime(100, t + 0.8); // Down
                    gain.gain.setValueAtTime(0.3, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.8);
                    osc.connect(gain); gain.connect(this.masterGain);
                    osc.start(); osc.stop(t + 0.8);
                }
                break;
            default:
                this.playExplosion();
        }
    }

    playExplosion() {
        if (!this.isEnabled) return;
        if (this.assets.explosion) return this.playBuffer(this.assets.explosion);

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine'; osc.frequency.setValueAtTime(100, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.4);
        gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
        osc.connect(gain); gain.connect(this.masterGain);
        osc.start(); osc.stop(t + 0.4);
    }

    playItemGet() {
        if (!this.isEnabled) return;
        if (this.assets.item_get) return this.playBuffer(this.assets.item_get);

        const t = this.ctx.currentTime;
        [523, 1046].forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(f, t + i * 0.05);
            gain.gain.setValueAtTime(0.1, t + i * 0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, t + i * 0.05 + 0.1);
            osc.connect(gain); gain.connect(this.masterGain);
            osc.start(t + i * 0.05); osc.stop(t + i * 0.05 + 0.1);
        });
    }

    playSelect() {
        if (!this.isEnabled) return;
        if (this.assets.select) return this.playBuffer(this.assets.select);

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(440, t);
        osc.frequency.exponentialRampToValueAtTime(880, t + 0.05);
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.05);
        osc.connect(gain); gain.connect(this.masterGain);
        osc.start(); osc.stop(t + 0.05);
    }

    playConfirm() {
        if (!this.isEnabled) return;
        if (this.assets.confirm) return this.playBuffer(this.assets.confirm);

        const t = this.ctx.currentTime;
        [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(f, t + i * 0.06);
            gain.gain.setValueAtTime(0.1, t + i * 0.06);
            gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.06 + 0.3);
            osc.connect(gain); gain.connect(this.masterGain);
            osc.start(t + i * 0.06); osc.stop(t + i * 0.06 + 0.3);
        });
    }

    playGameStart() {
        if (!this.isEnabled) return;
        if (this.assets.game_start) return this.playBuffer(this.assets.game_start);

        const t = this.ctx.currentTime;

        // ì¦‰ê°ì ì¸ í™•ì •ìŒ (Arpeggio) - "ë”©-ë§-ë”©-ë§~"
        [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(f, t + i * 0.06);
            gain.gain.setValueAtTime(0.15, t + i * 0.06);
            gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.06 + 0.4);
            osc.connect(gain); gain.connect(this.masterGain);
            osc.start(t + i * 0.06); osc.stop(t + i * 0.06 + 0.4);
        });
    }

    // --- BGM R&D Section ---

    /**
     * ìƒí™©ì— ë§ëŠ” ë°°ê²½ìŒì•… ì „í™˜
     * @param {string} type - 'START', 'SELECT', 'STAGE_1', 'STAGE_BOSS', 'ENDING' ë“±
     */
    startBGM(type = 'START') {
        if (!this.isEnabled) return;
        if (this.currentBgmType === type && (this.bgmLoop || this.bgmSource)) return;

        this.stopBGM();
        this.currentBgmType = type;
        this.beatCount = 0;

        // Asset BGM Check
        let assetKey = `bgm_${type.toLowerCase()}`;
        if (type.startsWith('STAGE_')) assetKey = null; // Map complex stage logic
        if (type === 'START') assetKey = 'bgm_start';
        else if (type === 'ENDING') assetKey = 'bgm_ending';

        // Complex mapping fallback
        if (!this.assets[assetKey] && type.startsWith('STAGE_')) {
            const stage = parseInt(type.split('_')[1]);
            if (stage <= 3) assetKey = 'bgm_stage_low';
            else if (stage <= 7) assetKey = 'bgm_stage_mid';
            else assetKey = 'bgm_stage_high';
        }

        if (this.assets[assetKey]) {
            this.bgmSource = this.playBuffer(this.assets[assetKey], 0.4, true);
            console.log(`ğŸ¶ Playing BGM (File): ${assetKey}`);
            return;
        }

        // Procedural Fallback
        const config = this.getBgmConfig(type);
        const beatTime = 60 / config.tempo;

        const masterGain = this.ctx.createGain();
        masterGain.gain.value = config.volume;
        if (this.reverbNode) {
            masterGain.connect(this.reverbNode);
            this.reverbNode.connect(this.masterGain); // Route reverb to master
        }
        masterGain.connect(this.masterGain); // Route dry to master

        this.bgmLoop = setInterval(() => {
            if (this.ctx.state === 'suspended') this.ctx.resume();

            const measure = Math.floor(this.beatCount / 4) % config.melody.length;
            const beat = this.beatCount % 4;

            // Bass
            if (beat === 0) {
                this.genNote(config.bass[measure % config.bass.length], beatTime * 1.5, 'sine', 0.2, masterGain);
            }

            // Melody
            const note = config.melody[measure][beat];
            if (note > 0) {
                this.genNote(note, 0.2, config.osc, 0.1, masterGain);
            }

            this.beatCount++;
        }, beatTime * 1000);

        console.log(`ğŸ¶ Playing BGM (Synth): ${type}`);
    }

    getBgmConfig(type) {
        // [R&D] ìƒí™©ë³„ ìŒì•… ë°ì´í„°ë² ì´ìŠ¤
        const themes = {
            'START': {
                tempo: 100, volume: 0.35, osc: 'triangle',
                bass: [130.81, 164.81, 196.00, 174.61], // C, E, G, F
                melody: [
                    [392, 523, 659, 784], // G, C, E, G
                    [329, 392, 523, 659], // E, G, C, E
                    [392, 523, 659, 784],
                    [440, 523, 659, 698]  // A, C, E, F
                ]
            },
            'SELECT': {
                tempo: 140, volume: 0.2, osc: 'square',
                bass: [196.00, 220.00], // G, A
                melody: [[392, 0, 440, 0], [493, 0, 523, 0]] // Staccato
            },
            'STAGE_LOW': { // Stages 1-3 (Peaceful)
                tempo: 120, volume: 0.25, osc: 'triangle',
                bass: [130.81, 196.00, 220.00, 174.61],
                melody: [[261, 0, 329, 392], [196, 0, 220, 246]]
            },
            'STAGE_MID': { // Stages 4-7 (Tense)
                tempo: 140, volume: 0.25, osc: 'sawtooth',
                bass: [110.00, 130.81, 146.83, 123.47], // Am, C, D, B
                melody: [[220, 220, 329, 329], [293, 293, 246, 246]]
            },
            'STAGE_HIGH': { // Stages 8-10 (Epic)
                tempo: 160, volume: 0.3, osc: 'square',
                bass: [87.31, 110.00, 116.54, 130.81], // F, A, Bb, C
                melody: [[349, 440, 466, 523], [698, 880, 932, 1046]]
            },
            'ENDING': {
                tempo: 80, volume: 0.4, osc: 'sine',
                bass: [130.81, 174.61, 196.00, 130.81],
                melody: [[523, 0, 0, 0], [698, 0, 0, 0], [784, 0, 0, 0], [1046, 0, 0, 0]]
            }
        };

        if (type.startsWith('STAGE_')) {
            const stage = parseInt(type.split('_')[1]);
            if (stage <= 3) return themes['STAGE_LOW'];
            if (stage <= 7) return themes['STAGE_MID'];
            return themes['STAGE_HIGH'];
        }
        return themes[type] || themes['STAGE_LOW'];
    }

    genNote(freq, dur, type, vol, dest) {
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.value = freq;
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(vol, t + 0.05);
        gain.gain.linearRampToValueAtTime(0, t + dur);
        osc.connect(gain); gain.connect(dest);
        osc.start(); osc.stop(t + dur);
    }

    stopBGM() {
        if (this.bgmLoop) {
            clearInterval(this.bgmLoop);
            this.bgmLoop = null;
        }
        if (this.bgmSource) {
            this.bgmSource.stop();
            this.bgmSource = null;
        }
    }
}
const sound = new SoundEngine();

/* --- pixel_art_v2.js --- */
// [Ultra Pixel Art Engine V4] - High Fidelity & Performance



// Helper: í”½ì…€ ê·¸ë¦¬ê¸° (ì¢Œí‘œ ë³´ì • í¬í•¨)
const drawRect = (ctx, x, y, w, h, color) => {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
};

// Helper: ìºë¦­í„° ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ë°˜ì „ ì²˜ë¦¬ ë° ë¡œë”© ìƒíƒœ í™•ì¸)
const drawCharImg = (ctx, img, x, y, w, h, flip = false) => {
    if (!img || !img.complete || img.naturalWidth === 0) return false;
    ctx.save();
    if (flip) {
        ctx.translate(Math.floor(x + w), Math.floor(y));
        ctx.scale(-1, 1);
        ctx.drawImage(img, 0, 0, Math.floor(w), Math.floor(h));
    } else {
        ctx.drawImage(img, Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
    }
    ctx.restore();
    return true;
};

// [High-Fidelity] Pixel Grid Helper
const drawPixelGrid = (ctx, x, y, size, grid) => {
    grid.forEach((row, ry) => {
        row.split('').forEach((pixel, rx) => {
            if (pixel === ' ') return;
            const colors = {
                'K': '#1A1A1A', // Rich Black Outline
                'W': '#FFFFFF', // Pure White Sparkle
                'Y': '#FFD54F', // Warm Honey Gold
                'y': '#FFA000', // Rich Amber Shadow
                'M': '#795548', // Chocolate Fedora Brown
                'm': '#4E342E', // Dark Espresso Brown
                'B': '#2D1B17', // Near-Black Hat Band
                'p': '#FFC1CF', // Soft Pastel Pink Blush
                'g': 'rgba(200, 230, 255, 0.4)', // Glassy Transparent Wing
                'S': '#FFF9C4', // Soft Creamy Highlight
                'O': '#FF8F00', // Deep Orange-Honey shading
                'H': '#FFF176'  // Bright Yellow Accent
            };
            drawRect(ctx, x + rx * size, y + ry * size, size, size, colors[pixel] || '#FF00FF');
        });
    });
};

// 1. Hero (Toto) - V12 [FINAL TRUE 1:1 REPLICATION]
// ì´ ë²„ì „ì€ ê¸°ì¡´ì˜ ë§ˆìŠ¤í„°ë³¸ì…ë‹ˆë‹¤.
// 1. Hero (Toto) - V12 [FINAL TRUE 1:1 REPLICATION]
// ì´ ë²„ì „ì€ ê¸°ì¡´ì˜ ë§ˆìŠ¤í„°ë³¸ì…ë‹ˆë‹¤.
function drawPixelTotoV2(ctx, x, y, w, h, vy = 0) {
    drawPixelTotoV5(ctx, x, y, w, h, vy);
}

// 1-B. Hero (Toto) - V5 [HONEY BEE REDESIGN]
// í•œìˆœì´ AD: "ìš¸íŠ¸ë¼ ë””í…Œì¼ 2D í”½ì…€ ì•„íŠ¸ ìŠ¤íƒ€ì¼ë¡œ ì¬í•´ì„í•œ ê¿€ë²Œ ë˜ë˜ì…ë‹ˆë‹¤."
function drawPixelTotoV5(ctx, x, y, w, h, vy = 0) {
    if (drawCharImg(ctx, PLAYER_IMAGES.ch_player1, x, y, w, h)) return;

    // Fallback to procedural if image not loaded
    const t = Date.now() / 1000;
    const hoverY = Math.sin(t * 8) * 6;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2 + hoverY);
    ctx.scale(-1, 1);

    const colors = {
        'B': '#3E2723', 'Y': '#FFD54F', 'y': '#FFA000', 'O': '#E65100',
        'H': '#FFF9C4', 'W': '#FFFFFF', 'E': '#1A1A1A', 'g': 'rgba(200, 230, 255, 0.4)', 'p': '#FFAB91'
    };

    const beeGrid = [
        "          BBBBBBBBBB            ",
        "        BBHHHHHHHHHHBB          ",
        "      BBHHHHHHHHHHHHHHBB        ",
        "    BBHHHHHHHHHHHHHHHHHHBB      ",
        "    BBHHHHHHHHHHHHHHHHHHBB      ",
        "  BBHHHHHHHHHHHHHHHHHHHHHHBB    ",
        "  BBHHHHHHHHHHHHHHHHHHHHHHBB    ",
        "BBHHHHHHHHHHHHHHHHHHHHHHHHHHBB  ",
        "BBHHHHHHHHHBBBBBBBBBBHHHHHHHBB  ",
        "BBHHHHHHBBBEEEEEEEEEEBBBHHHHBB  ",
        "BBHHHHBBEEEEEEEEEEEEEEEEBBHHBB  ",
        "BBHHHBBEEEEEEWWWEEEEEEEEEBBHBB  ",
        "BBHHHBBEEEEEWWWWWEEEEEEEEEBBHBB ",
        "BBHHHBBEEEEEWWWWWEEEEEEEEEBBHBB ",
        "BBHHHBBEEEEEEWWWEEEEEEEEEBBHBB  ",
        "BBHHHBBEEEEEEEEEWWWEEEEEEBBHBB  ",
        "BBHHHBBEEEEEEEEWWWWWEEEEEBBHBB  ",
        "BBHHHBBEEEEEEEEWWWWWEEEEEBBHBB  ",
        "BBHHHHBBEEEEEEEEWWWEEEEBBHHBB   ",
        "BBHHHHHBBBBEEEEEEEEBBBBHHHHHBB  ",
        "BBHHHHHHHHHBBBBBBBBHHHHHHHHHBB  ",
        "  BBHHHHHHHHHHHHHHHHHHHHHHBB    ",
        "  BBHHHHYYppHHHHHHppYYHHHHBB    ",
        "    BBHHppppHHHHHHppppHHBB      ",
        "    BBHHHHYYYYYYYYYYYYHHBB      ",
        "      BBHHHHHHHHHHHHHHBB        ",
        "        BBHHHHHHHHHHBB          ",
        "   gggg   BBBBBBBBBB   gggg     ",
        " gggggggg  BBBBBBBB  gggggggg   ",
        " gggggggg  BBBBBBBB  gggggggg   ",
        "  gggggg     BBBB     gggggg    ",
        "             BBBB               "
    ];

    beeGrid.forEach((row, ry) => {
        row.split('').forEach((pixel, rx) => {
            if (pixel === ' ') return;
            drawRect(ctx, -w / 2 + rx * pSize, -h / 2 + ry * pSize, pSize, pSize, colors[pixel]);
        });
    });

    ctx.restore();
}

// 1-C. Bit Bee (Funnel) - Mini Toto
function drawBitBee(ctx, x, y, w, h) {
    // We use drawPixelTotoV5 with a smaller size (32x32 typically passed from entities)
    // To distinguish them, we can add a slight glow or just use them as is
    ctx.save();
    // drawPixelTotoV5 handles its own hover and scale(-1, 1), so we just position it
    drawPixelTotoV5(ctx, x, y, w, h);
    ctx.restore();
}

// 2. Enemy (Wasp) - Pixel Grid High Detail
function drawPixelWaspV2(ctx, x, y, w, h) {
    const cx = x;
    const cy = y;
    const t = Date.now() / 1000;
    const hover = Math.sin(t * 10) * 4;
    const pSize = w / 16;

    // Wing Animation
    const wingColor = Math.sin(t * 40) > 0 ? 'rgba(255,255,255,0.4)' : 'rgba(200,200,255,0.2)';
    ctx.fillStyle = wingColor;
    ctx.fillRect(x + 4, y - 10 + hover, 24, 10);

    // [Detail] 16x16 Pixel Map for Wasp
    const waspGrid = [
        "      XXXX      ",
        "    XXyyyyXX    ",
        "  XXyyyyyyyyXX  ",
        " XyyyyyyyyyyyyX ",
        "XyyKKKyyyyKKKyyX", // Eyes
        "XyKKrKyyyyKrKKyX", // Scouter Red
        "XyKKKKyyyyKKKKyX",
        "XooooooooooooooX", // Stripe 1
        "XooooooooooooooX",
        "XssssssssssssssX", // Metal Part
        " XssssssssssssX ",
        "  XssssssssssX  ",
        "   XssssssssX   ",
        "    XXssssXX    ",
        "      XXXX      ",
        "       RR       "  // Stinger
    ];

    drawPixelGrid(ctx, cx, cy + hover, pSize, waspGrid);

    // Booster Effect
    const flame = Math.random() * 15;
    drawRect(ctx, x + w - 4, y + h / 2 - 2 + hover, flame, 4, '#00e5ff');
}

// 2-B. Boss (Buzz) - Ultimate Detail V1
// 2-B. Boss (Buzz) - Ultimate Pixel Grid
function drawPixelBossBuzzV2(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const hover = Math.sin(t * 5) * 15;
    const pSize = w / 32;

    const bossGrid = [
        "      XXXXXXXXXXXXXXXXXXXX      ",
        "    XXssssssssssssssssssssXX    ",
        "  XXssssssssssssssssssssssssXX  ",
        " XsssssssssXXXXXXXXsssssssssssX ",
        "XssssssssXXKKKKKKKKXXssssssssssX", // Head Plate
        "XsssssssXKKKKKKKKKKKKXsssssssssX",
        "XsssssssXKKKrKKKKKKKKXsssssssssX", // Pulsing Eye
        "XssssssssXXKKKKKKKKXXssssssssssX",
        "XyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyX", // Gold Stripe
        "XyyyyyyyyyX........XyyyyyyyyyyyX", // Rivets in center
        "XooooooooooooooooooooooooooooooX", // Shadow Stripe
        " XssssssssssssssssssssssssssssX ",
        "  XssssssssssX..XssssssssssssX  ",
        "   XXssssssssssssssssssssssXX   ",
        "     XXXXXXXXXXXXXXXXXXXXXX     "
    ];

    drawPixelGrid(ctx, x, y + hover, pSize, bossGrid);

    // [Side Detail] Gatling Gun (Pixelated)
    drawRect(ctx, x - 20, y + 40 + hover, 30, 20, '#263238');
    drawRect(ctx, x - 30, y + 45 + hover, 35, 10, '#455a64');

    // [Detail] Boosters
    const colors = ['#00e5ff', '#00b0ff', '#2979ff', '#3d5afe'];
    for (let i = 0; i < 4; i++) {
        const fy = y + 15 + i * 25 + hover;
        const beamLen = 30 + Math.random() * 20;
        drawRect(ctx, x + w - 5, fy, beamLen, 10, colors[i]);
    }
}

// 3. Enemy (Butterfly) - Pixel Grid V1
function drawPixelButterflyV2(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const flap = Math.sin(t * 15) > 0;
    const pSize = w / 16;

    const butterflyGrid = flap ? [
        "  MMMM    MMMM  ",
        " MMMMMMM MMMMMMM",
        "MMMMMMMMMMMMMMMM",
        "MMMMMMMMMMMMMMMM",
        " MMMMMMMMMMMMMM ",
        "  MMMMMMMMMMMM  ",
        "   MMMKKKKMMM   ",
        "    MKKKKKKM    ",
        "     KKKKKK     ",
        "    KKKKKKKK    ",
        "   KKKKKKKKKK   ",
        "  MMMMMMMMMMMM  ",
        " MMMMMMMMMMMMMM ",
        "MMMMMMMMMMMMMMMM",
        "MMMMMMMMMMMMMMMM",
        " MMMMMMM MMMMMMM"
    ] : [
        "      MMMM      ",
        "     MMMMMM     ",
        "    MMMMMMMM    ",
        "   MMMMMMMMMM   ",
        "  MMMMKKKKMMMM  ",
        " MMMMMKKKKMMMMM ",
        "MMMMMMKKKKMMMMMM",
        "MMMMMMKKKKMMMMMM",
        "MMMMMMKKKKMMMMMM",
        " MMMMMKKKKMMMMM ",
        "  MMMMKKKKMMMM  ",
        "   MMMMMMMMMM   ",
        "    MMMMMMMM    ",
        "     MMMMMM     ",
        "      MMMM      ",
        "                "
    ];

    drawPixelGrid(ctx, x, y, pSize, butterflyGrid);
}

// 4. Enemy (Beetle) - Pixel Grid V1
function drawPixelBeetleV2(ctx, x, y, w, h) {
    const pSize = w / 16;
    const beetleGrid = [
        "      XXXX      ",
        "    XXssssXX    ",
        "  XXssssssssXX  ",
        " XssssssssssssX ",
        "XssssssssssssssX",
        "XsssssXXXXsssssX",
        "XssssXXKKXXssssX",
        "XssssXKKKKXssssX",
        "XooooooooooooooX",
        "XooooooooooooooX",
        "XssssssssssssssX",
        " XssssssssssssX ",
        "  XXssssssssXX  ",
        "    XXssssXX    ",
        "      XXXX      ",
        "     KK  KK     "
    ];
    drawPixelGrid(ctx, x, y, pSize, beetleGrid);
}

// 5. Enemy (Drone) - Pixel Grid V1
function drawPixelDroneV2(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 16;
    const droneGrid = [
        "      XXXX      ",
        "    XXssssXX    ",
        "  XXssssssssXX  ",
        " XssssXXXXXXXXX ", // Offset for fake rotation
        "XssssXXRRRRRRXXS", // Red Lens
        "XssssXRRRRRRRRXS",
        "XssssXXRRRRRRXXS",
        "XssssXXXXXXXXXXS",
        "XssssssssssssssS",
        " XssssssssssssX ",
        "  XXssssssssXX  ",
        "    XXssssXX    ",
        "      XXXX      ",
        "     KK  KK     ",
        "    KK    KK    ",
        "                "
    ];
    drawPixelGrid(ctx, x, y, pSize, droneGrid);
}

// 6. Enemy (Ghost) - Pixel Grid V1
function drawPixelGhostV2(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 16;
    const ghostGrid = [
        "      WWWW      ",
        "    WWWWWWWW    ",
        "   WWWWWWWWWW   ",
        "  WWWWWWWWWWWW  ",
        " WWWWWWWWWWWWWW ",
        "WWWWWWWWWWWWWWWW",
        "WWWKKWWWWWWKKWWW", // Eyes
        "WWKKKKWWWWKKKKWW",
        "WWKKKKWWWWKKKKWW",
        "WWWWWWWWWWWWWWWW",
        "WWWWWWWWWWWWWWWW",
        " WWWWWWWWWWWWWW ",
        "  WW  WW  WW  W ",
        "   W   W   W    ",
        "                ",
        "                "
    ];
    ctx.save();
    ctx.globalAlpha = 0.7;
    drawPixelGrid(ctx, x, y + Math.sin(t * 5) * 5, pSize, ghostGrid);
    ctx.restore();
}

// 7. Enemy (Slime) - Pixel Grid V1
function drawPixelSlimeV2(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 16;
    const slimeGrid = [
        "                ",
        "      GGGG      ",
        "    GGGGGGGG    ",
        "   GGGGGGGGGG   ",
        "  GGGGGGGGGGGG  ",
        " GGGGGGGGGGGGGG ",
        "GGGGGKGGGGGKGGGG", // Eyes
        "GGGGKKKGGGGKKKGG",
        "GGGGGGGGGGGGGGGG",
        " GGGGGGGGGGGGGG ",
        "  GGGGGGGGGGGG  ",
        "   GGGGGGGGGG   ",
        "    GGGGGGGG    ",
        "      GGGG      ",
        "                ",
        "                "
    ];
    const squish = Math.sin(t * 10) * 0.1;
    ctx.save();
    ctx.translate(x + w / 2, y + h);
    ctx.scale(1 + squish, 1 - squish);
    drawPixelGrid(ctx, -w / 2, -h, pSize, slimeGrid);
    ctx.restore();
}


// 3.5 Enemies Continued...

// Background - High Quality Pixel Art Version (V3)
// SEAMLESS LOOPING FIX: Using modulo and extra tile padding to ensure zero jumping.
function drawPixelForestV2(ctx, CONFIG, state) {
    const stage = state.currentStage || 1;
    const bgOffset = state.bgOffset || 0;

    const envStyles = {
        1: { // PixelSky Theme
            skyTop: '#0d47a1', skyBot: '#42a5f5', sunColor: 'rgba(255, 255, 255, 0.2)',
            treeColor: (c) => `rgba(255, 255, 255, ${c * 0.3})`, groundColor: '#1565c0',
            detailColor: '#1e88e5', accentColor: '#bbdefb', godRays: false
        },
        2: { // Night
            skyTop: '#0d1117', skyBot: '#161b22', sunColor: 'rgba(255,255,255,0.1)',
            treeColor: (c) => `rgba(13, 25, 48, ${c})`, groundColor: '#050a14',
            detailColor: '#1f2937', accentColor: '#38bdf8', godRays: false
        },
        3: { // Sunset
            skyTop: '#4c1d95', skyBot: '#db2777', sunColor: 'rgba(251, 146, 60, 0.3)',
            treeColor: (c) => `rgba(88, 28, 135, ${c})`, groundColor: '#4c1d95',
            detailColor: '#7c3aed', accentColor: '#fcd34d', godRays: true
        }
    };

    const style = envStyles[stage] || envStyles[stage % 3 || 1];

    // 1. Sky Gradient
    const grad = ctx.createLinearGradient(0, 0, 0, CONFIG.SCREEN_HEIGHT);
    grad.addColorStop(0, style.skyTop); grad.addColorStop(1, style.skyBot);
    ctx.fillStyle = grad; ctx.fillRect(0, 0, CONFIG.SCREEN_WIDTH, CONFIG.SCREEN_HEIGHT);

    // [New Stage 1 Theme] PixelSky Implementation
    if (stage === 1) {
        let layersDrawn = 0;
        const drawLayer = (img, speed) => {
            if (!img || !img.complete || img.naturalWidth === 0) return false;
            const width = CONFIG.SCREEN_WIDTH;
            let x = (bgOffset * speed) % width;
            if (x > 0) x -= width;
            x = Math.floor(x);
            ctx.drawImage(img, x, 0, width + 1, CONFIG.SCREEN_HEIGHT);
            ctx.drawImage(img, x + width, 0, width + 1, CONFIG.SCREEN_HEIGHT);
            layersDrawn++;
            return true;
        };
        drawLayer(BACKGROUND_IMAGES.layer01, 0.2);
        drawLayer(BACKGROUND_IMAGES.layer02, 0.5);
        drawLayer(BACKGROUND_IMAGES.layer03, 0.8);

        if (layersDrawn > 0) return; // Only skip procedural if we actually drew PNG layers
    }

    // 2. Parallax Clouds
    const drawCloud = (cx, cy, scale, alpha) => {
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        drawRect(ctx, -20, 0, 40, 20); drawRect(ctx, -10, -10, 30, 10);
        drawRect(ctx, 10, 0, 20, 10); drawRect(ctx, -30, 5, 20, 10);
        ctx.restore();
    };

    const cloudSpacing = 500;
    const cloudCount = Math.ceil(CONFIG.SCREEN_WIDTH / cloudSpacing) + 2;
    for (let i = 0; i < cloudCount; i++) {
        const speedFactor = 0.5;
        const x = ((i * cloudSpacing) + (bgOffset * speedFactor) % cloudSpacing) - cloudSpacing;
        drawCloud(x, 100 + (i % 3) * 40, 1.5 + (i % 2) * 0.2, 0.25);
    }

    // 3. God Rays
    if (style.godRays) {
        ctx.save();
        ctx.globalCompositeOperation = 'overlay';
        const time = Date.now() / 2000;
        for (let i = 0; i < 5; i++) {
            const bx = ((i * 300) + (bgOffset * 0.2)) % CONFIG.SCREEN_WIDTH;
            const bWidth = 100 + Math.sin(time + i) * 20;
            const gradBeam = ctx.createLinearGradient(bx, 0, bx + 100, CONFIG.SCREEN_HEIGHT);
            gradBeam.addColorStop(0, style.sunColor); gradBeam.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradBeam;
            ctx.beginPath(); ctx.moveTo(bx, 0); ctx.lineTo(bx + bWidth, 0);
            ctx.lineTo(bx + bWidth - 150, CONFIG.SCREEN_HEIGHT); ctx.lineTo(bx - 150, CONFIG.SCREEN_HEIGHT);
            ctx.fill();
        }
        ctx.restore();
    }

    // 4. Parallax Trees
    // Far Layer (Slow)
    const farSpacing = 300;
    const farCount = Math.ceil(CONFIG.SCREEN_WIDTH / farSpacing) + 2;
    ctx.fillStyle = style.treeColor(0.2);
    for (let i = 0; i < farCount; i++) {
        const x = ((i * farSpacing) + (bgOffset * 0.4) % farSpacing) - farSpacing;
        ctx.beginPath();
        ctx.moveTo(x, CONFIG.SCREEN_HEIGHT - 60);
        ctx.lineTo(x + 60, CONFIG.SCREEN_HEIGHT - 280);
        ctx.lineTo(x + 120, CONFIG.SCREEN_HEIGHT - 60);
        ctx.fill();
    }

    // Near Layer (Faster)
    const drawHQTree = (tx, ty, s, c) => {
        drawRect(ctx, tx - 4 * s, ty - 40 * s, 8 * s, 40 * s, '#211815'); // Darker trunk
        ctx.fillStyle = c;
        drawRect(ctx, tx - 22 * s, ty - 65 * s, 44 * s, 35 * s);
        drawRect(ctx, tx - 15 * s, ty - 85 * s, 30 * s, 25 * s);
        drawRect(ctx, tx - 8 * s, ty - 100 * s, 16 * s, 20 * s);
    };

    const nearSpacing = 450;
    const nearCount = Math.ceil(CONFIG.SCREEN_WIDTH / nearSpacing) + 2;
    for (let i = 0; i < nearCount; i++) {
        const x = ((i * nearSpacing) + (bgOffset % nearSpacing)) - nearSpacing;
        drawHQTree(x + 200, CONFIG.SCREEN_HEIGHT - 60, 2.8, style.treeColor(1));
    }

    // 5. Ground with Texture
    ctx.fillStyle = style.groundColor;
    ctx.fillRect(0, CONFIG.SCREEN_HEIGHT - 60, CONFIG.SCREEN_WIDTH, 60);

    // Grass Tufts (Seamless)
    const grassSpacing = 150;
    const grassCount = Math.ceil(CONFIG.SCREEN_WIDTH / grassSpacing) + 2;
    ctx.fillStyle = style.detailColor;
    for (let i = 0; i < grassCount; i++) {
        const gx = ((i * grassSpacing) + (bgOffset * 2 % grassSpacing)) - grassSpacing;
        drawRect(ctx, gx, CONFIG.SCREEN_HEIGHT - 65, 20, 12);
        drawRect(ctx, gx + 6, CONFIG.SCREEN_HEIGHT - 72, 8, 8);
    }

    // Tiny Flowers (Seamless)
    const flowerSpacing = 250;
    const flowerCount = Math.ceil(CONFIG.SCREEN_WIDTH / flowerSpacing) + 2;
    ctx.fillStyle = style.accentColor;
    for (let i = 0; i < flowerCount; i++) {
        const fx = ((i * flowerSpacing) + (bgOffset * 2 % flowerSpacing)) - flowerSpacing + 75;
        drawRect(ctx, fx, CONFIG.SCREEN_HEIGHT - 64, 6, 6);
    }
}

// 2-C. Boss (Queen Arachne) - Pixel Block Design
function drawPixelQueenArachne(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);
    ctx.translate(0, Math.sin(t * 3) * 10);

    // 1. Abdomen (Huge Pixel Map Cluster)
    const abdSize = pSize * 2;
    ctx.fillStyle = '#311b92';
    drawRect(ctx, -20 * pSize, -25 * pSize, 40 * pSize, 35 * pSize); // Core
    ctx.fillStyle = '#4527a0';
    drawRect(ctx, -15 * pSize, -20 * pSize, 30 * pSize, 25 * pSize); // Detail

    // Poison Sac (Blinking Pixel)
    const pulse = (Math.sin(t * 15) + 1) / 2;
    ctx.fillStyle = `rgba(255, 23, 68, ${0.5 + pulse * 0.5})`;
    drawRect(ctx, -8 * pSize, -15 * pSize, 16 * pSize, 16 * pSize);

    // 2. Head
    ctx.fillStyle = '#212121';
    drawRect(ctx, -12 * pSize, 10 * pSize, 24 * pSize, 20 * pSize);

    // Eyes (Multiple Red Dots)
    ctx.fillStyle = '#ff1744';
    drawRect(ctx, -8 * pSize, 15 * pSize, 4 * pSize, 4 * pSize);
    drawRect(ctx, 4 * pSize, 15 * pSize, 4 * pSize, 4 * pSize);
    drawRect(ctx, -10 * pSize, 10 * pSize, 2 * pSize, 2 * pSize);
    drawRect(ctx, 8 * pSize, 10 * pSize, 2 * pSize, 2 * pSize);

    // 3. Legs (Segmented Pixel Beams)
    ctx.fillStyle = '#424242';
    for (let i = 0; i < 4; i++) {
        const side = i < 2 ? -1 : 1;
        const ang = (side * Math.PI / 4) + Math.sin(t * 10 + i) * 0.2;
        ctx.save();
        ctx.rotate(ang);
        drawRect(ctx, side * 10 * pSize, 0, side * 30 * pSize, 6 * pSize);
        ctx.translate(side * 30 * pSize, 0);
        ctx.rotate(side * 0.5);
        drawRect(ctx, 0, 0, side * 30 * pSize, 4 * pSize);
        ctx.restore();
    }

    ctx.restore();
}

// 2-D. Boss (Metal Orochi) - Pixel Snake V1
function drawPixelMetalOrochi(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 64;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);

    // 1. Body Segments (Blocky Chain)
    for (let i = 6; i > 0; i--) {
        const segX = Math.sin(t * 5 + i) * 30;
        const segY = i * 40;
        ctx.save();
        ctx.translate(segX, segY);
        drawRect(ctx, -30, -20, 60, 40, '#263238'); // Main Frame
        drawRect(ctx, -25, -15, 50, 10, '#37474f'); // Top Armor
        drawRect(ctx, -20, 10, 40, 6, '#00e5ff');   // Energy Core Pulse
        ctx.restore();
    }

    // 2. Head (Mechanical Dragon)
    const hx = Math.sin(t * 5) * 30;
    ctx.translate(hx, 0);

    // Head Map
    const headGrid = [
        "      XXXXXX      ",
        "    XXXXXXXXXX    ",
        "   XXXXXXXXXXXX   ",
        "  XXXXCCXXXXCCXX  ", // CC = Blue Eyes
        "  XXXXCCXXXXCCXX  ",
        " XXXXXXXXXXXXXXXX ",
        "XXXXXXXXXXXXXXXXXX",
        "XXXXXXKKKKKKXXXXXX", // Mouth
        "XXXXXKKKKKKKKXXXXX",
        "XXXXXKKKKKKKKXXXXX",
        "XXXXXXKKKKKKXXXXXX",
        "XXXXXXXXXXXXXXXXXX",
        " XXXXXXXXXXXXXXXX ",
        "  XXXXXXXXXXXXXX  ",
        "   XXXXXXXXXXXX   ",
        "     XXXXXXXX     "
    ];

    // Replace C with Blue Energy
    const sizeHead = w / 2 / 16;
    drawPixelGrid(ctx, -w / 4, -h / 4, sizeHead, headGrid);

    ctx.restore();
}

// 2-E. Boss (Storm Falcon) - Pixel Ace V1
function drawPixelStormFalcon(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);
    ctx.translate(0, Math.sin(t * 10) * 8); // Fast flap jitter

    // 1. Mechanical Wings (Sharp Pixel Planes)
    const flap = Math.cos(t * 15) * 15;
    ctx.fillStyle = '#cfd8dc';
    // Left Wing
    ctx.save();
    ctx.rotate(flap * Math.PI / 180);
    drawRect(ctx, -50 * pSize, -10 * pSize, 50 * pSize, 12 * pSize);
    drawRect(ctx, -40 * pSize, 2 * pSize, 30 * pSize, 8 * pSize);
    ctx.restore();
    // Right Wing
    ctx.save();
    ctx.rotate(-flap * Math.PI / 180);
    drawRect(ctx, 0, -10 * pSize, 50 * pSize, 12 * pSize);
    drawRect(ctx, 10 * pSize, 2 * pSize, 30 * pSize, 8 * pSize);
    ctx.restore();

    // 2. Body & Cockpit
    ctx.fillStyle = '#37474f';
    drawRect(ctx, -10 * pSize, -15 * pSize, 20 * pSize, 40 * pSize);

    const cockpitGrid = [
        "    CCCC    ",
        "   CCCCCC   ",
        "  CCCCCCCC  ",
        " CCCCCCCCCC ",
        "CCCCCCCCCCCC",
        "CCCCCCCCCCCC"
    ];
    // C = Blue Glass
    drawPixelGrid(ctx, -6 * pSize, -20 * pSize, pSize, cockpitGrid);

    // 3. Turbo Boosters
    const pulse = (Math.sin(t * 20) + 1) / 2;
    ctx.fillStyle = '#00e5ff';
    drawRect(ctx, -12 * pSize, 20 * pSize, 4 * pSize, 10 * pSize + pulse * 10);
    drawRect(ctx, 8 * pSize, 20 * pSize, 4 * pSize, 10 * pSize + pulse * 10);

    ctx.restore();
}

// 2-F. Boss (Phantom Moth) - Pixel Mirage V1
function drawPixelPhantomMoth(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);

    // 1. Ghost Trails (Pixel Outlines)
    for (let i = 1; i <= 2; i++) {
        ctx.save();
        ctx.globalAlpha = 0.2 / i;
        ctx.translate(Math.sin(t * 5 + i) * 30, Math.cos(t * 5 + i) * 30);
        ctx.fillStyle = '#ba68c8';
        drawRect(ctx, -20 * pSize, -20 * pSize, 40 * pSize, 40 * pSize);
        ctx.restore();
    }

    // 2. Main Wings (Dithered Pattern)
    const scale = 1 - Math.sin(t * 8) * 0.2;
    ctx.save();
    ctx.scale(1, scale);

    // Wing Map (Upper)
    ctx.fillStyle = '#4a148c';
    drawRect(ctx, -35 * pSize, -25 * pSize, 30 * pSize, 40 * pSize);
    drawRect(ctx, 5 * pSize, -25 * pSize, 30 * pSize, 40 * pSize);

    // Pattern Eye
    ctx.fillStyle = '#ea80fc';
    drawRect(ctx, -25 * pSize, -10 * pSize, 10 * pSize, 10 * pSize);
    drawRect(ctx, 15 * pSize, -10 * pSize, 10 * pSize, 10 * pSize);

    ctx.restore();

    // 3. Body
    ctx.fillStyle = '#212121';
    drawRect(ctx, -8 * pSize, -15 * pSize, 16 * pSize, 30 * pSize);

    // Glowing Eyes
    const glow = (Math.sin(t * 10) + 1) / 2;
    ctx.fillStyle = `rgba(0, 230, 118, ${0.5 + glow * 0.5})`;
    drawRect(ctx, -5 * pSize, -10 * pSize, 4 * pSize, 4 * pSize);
    drawRect(ctx, 1 * pSize, -10 * pSize, 4 * pSize, 4 * pSize);

    ctx.restore();
}

// 2-G. Boss (Flame Salamander) - Pixel Drake V1
function drawPixelFlameSalamander(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);

    // 1. Armored Body
    ctx.fillStyle = '#bf360c';
    drawRect(ctx, -25 * pSize, -10 * pSize, 50 * pSize, 20 * pSize);
    drawRect(ctx, 20 * pSize, -15 * pSize, 15 * pSize, 30 * pSize); // Head

    // 2. Fire Tail (Segmented Dots)
    for (let i = 0; i < 5; i++) {
        const tx = -30 * pSize - (i * 10 * pSize);
        const ty = Math.sin(t * 10 + i) * 15;
        const colors = ['#ffab91', '#ff5722', '#e64a19', '#bf360c'];
        ctx.fillStyle = colors[i % 4];
        drawRect(ctx, tx, ty, 8 * pSize, 8 * pSize);
    }

    // 3. Molten Eyes
    ctx.fillStyle = '#ffff00';
    drawRect(ctx, 28 * pSize, -8 * pSize, 4 * pSize, 4 * pSize);

    ctx.restore();
}

// 2-H. Boss (Junk Amalgam) - Pixel Scrap V1
function drawPixelJunkAmalgam(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);
    ctx.scale(1 + Math.sin(t * 2) * 0.05, 1 - Math.sin(t * 2) * 0.05);

    // 1. Scrap Blocks (Randomly stacked pixel clusters)
    const colors = ['#4e342e', '#3e2723', '#212121', '#455a64'];
    for (let i = 0; i < 12; i++) {
        const ox = Math.cos(i) * 20 * pSize;
        const oy = Math.sin(i * 1.5) * 20 * pSize;
        ctx.fillStyle = colors[i % 4];
        drawRect(ctx, ox, oy, 12 * pSize, 12 * pSize);
    }

    // 2. Burning Core
    const pulse = (Math.sin(t * 10) + 1) / 2;
    ctx.fillStyle = `rgba(255, 235, 59, ${0.8 + pulse * 0.2})`;
    drawRect(ctx, -6 * pSize, -6 * pSize, 12 * pSize, 12 * pSize);

    ctx.restore();
}

// 2-I. Boss (Toxic Chimera) - Pixel Terror V1
function drawPixelToxicChimera(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);

    // 1. Toxic Aura (Bubble Particles)
    for (let i = 0; i < 6; i++) {
        const ang = (t + i) % (Math.PI * 2);
        ctx.fillStyle = 'rgba(118, 255, 3, 0.4)';
        drawRect(ctx, Math.cos(ang) * 25 * pSize, Math.sin(ang) * 25 * pSize, 8 * pSize, 8 * pSize);
    }

    // 2. Main Body (Green Scales)
    ctx.fillStyle = '#1b5e20';
    drawRect(ctx, -20 * pSize, -15 * pSize, 40 * pSize, 35 * pSize);

    // 3. Multi-Head (Dot Design)
    ctx.fillStyle = '#f9a825'; // Head 1
    drawRect(ctx, -30 * pSize, -25 * pSize, 12 * pSize, 12 * pSize);
    ctx.fillStyle = '#00695c'; // Head 2 (Serpent)
    const snakeY = Math.sin(t * 5) * 5;
    drawRect(ctx, 15 * pSize, -25 * pSize + snakeY, 10 * pSize, 15 * pSize);

    ctx.restore();
}

// 2-J. Boss (Sky Fortress Core) - Pixel Engine V1
function drawPixelSkyFortressCore(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 48;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);

    // 1. Rotating Frame (Blocks)
    ctx.save();
    ctx.rotate(t * 0.5);
    ctx.fillStyle = '#263238';
    for (let i = 0; i < 6; i++) {
        ctx.rotate(Math.PI / 3);
        drawRect(ctx, 20 * pSize, -10 * pSize, 15 * pSize, 20 * pSize);
    }
    ctx.restore();

    // 2. Central Core Eye
    const eyeGrid = [
        "      RRRRRR      ",
        "    RRRRRRRRRR    ",
        "   RRRRRRRRRRRR   ",
        "  RRRRRRKKRRRRRR  ",
        "  RRRRRKKKKRRRRR  ",
        "  RRRRRKKKKRRRRR  ",
        "  RRRRRRKKRRRRRR  ",
        "   RRRRRRRRRRRR   ",
        "    RRRRRRRRRR    ",
        "      RRRRRR      "
    ];
    // R = Red Core, K = Pupil
    drawPixelGrid(ctx, -12 * pSize, -12 * pSize, pSize * 1.5, eyeGrid);

    ctx.restore();
}

// 2-K. Boss (Emperor "V") - Pixel King V1
function drawPixelEmperorV(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2);
    ctx.translate(0, Math.sin(t * 2) * 10); // Float

    // 1. Golden Throne (Pixel Stack)
    ctx.fillStyle = '#ffd700';
    drawRect(ctx, -15 * pSize, -20 * pSize, 30 * pSize, 40 * pSize);
    ctx.fillStyle = '#d50000'; // Velvet
    drawRect(ctx, -12 * pSize, -15 * pSize, 24 * pSize, 30 * pSize);

    // 2. The Emperor (Pixel Map)
    const kingGrid = [
        "      YYYY      ",
        "     YYYYYY     ",
        "    YYWWWWYY    ", // Crown
        "    YYYYYYYY    ",
        "   YYYYYYYYYY   ",
        "   WWWWWWWWWW   ", // Face
        "   WKKWWWWKKW   ", // Eyes
        "   WWWWWWWWWW   ",
        "  RRRRRRRRRRRR  ", // Cloak
        "  RRRRRRRRRRRR  ",
        "  RRRRRRRRRRRR  ",
        "   RRRRRRRRRR   ",
        "    RRRRRRRR    ",
        "     RRRRRR     "
    ];
    drawPixelGrid(ctx, -8 * pSize, -25 * pSize, pSize, kingGrid);

    // 3. Orbital Energy Swords
    const rot = t * 3;
    ctx.fillStyle = '#00e5ff';
    for (let i = 0; i < 4; i++) {
        const ang = rot + (Math.PI / 2) * i;
        drawRect(ctx, Math.cos(ang) * 22 * pSize, Math.sin(ang) * 22 * pSize, 6 * pSize, 6 * pSize);
    }

    ctx.restore();
}

// 9. Portraits
function drawPixelTotoPortrait(ctx, x, y, size = 120) {
    ctx.save();
    ctx.translate(x, y);
    drawPixelTotoV5(ctx, -size / 2, -size / 2, size, size, 0);
    ctx.restore();
}
function drawPixelLuluPortrait(ctx, x, y, size = 120) {
    ctx.save();
    ctx.translate(x, y);
    drawPixelLuluV2(ctx, -size / 2, -size / 2, size, size);
    ctx.restore();
}
function drawPixelKakaPortrait(ctx, x, y, size = 120) {
    ctx.save();
    ctx.translate(x, y);
    drawPixelKakaV2(ctx, -size / 2, -size / 2, size, size);
    ctx.restore();
}
function drawPixelMomoPortrait(ctx, x, y, size = 120) {
    ctx.save();
    ctx.translate(x, y);
    drawPixelMomoV2(ctx, -size / 2, -size / 2, size, size);
    ctx.restore();
}
function drawPixelPipiPortrait(ctx, x, y, size = 120) {
    ctx.save();
    ctx.translate(x, y);
    drawPixelPipiV2(ctx, -size / 2, -size / 2, size, size);
    ctx.restore();
}
function drawPixelFairyPortrait(ctx, x, y, size = 120) {
    ctx.save();
    ctx.translate(x, y);
    const t = Date.now() / 1000;
    ctx.fillStyle = 'rgba(129, 212, 250, 0.6)';
    const flap = Math.sin(t * 10) * 10;
    ctx.beginPath(); ctx.ellipse(-20, -10, 30 + flap, 15, Math.PI / 4, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(20, -10, 30 + flap, 15, -Math.PI / 4, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ffe0b2';
    ctx.beginPath(); ctx.arc(0, 0, size / 3, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
}

// 10. Items & Effects
function drawPixelItemV2(ctx, x, y, type) {
    const t = Date.now() / 1000;
    const hover = Math.sin(t * 5) * 5;
    const size = 32;

    ctx.save();
    ctx.translate(x + size / 2, y + size / 2 + hover);

    // ì™¸ê³½ ê´‘ì±„
    const pulse = (Math.sin(t * 10) + 1) / 2;
    ctx.shadowBlur = 10 + pulse * 10;
    ctx.shadowColor = type === 'P' ? '#ffeb3b' : (type === 'B' ? '#00e5ff' : '#76ff03');

    // ì•„ì´í…œ ë°•ìŠ¤
    drawRect(ctx, -16, -16, 32, 32, '#212121');
    drawRect(ctx, -14, -14, 28, 28, type === 'P' ? '#fbc02d' : (type === 'B' ? '#00b0ff' : '#43a047'));

    // í…ìŠ¤íŠ¸/ì‹¬ë³¼
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(type, 0, 0);

    ctx.restore();
}

// Helper: Hexagon for Toto
function drawHexagon(ctx, x, y, r) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        ctx.lineTo(x + r * Math.cos(Math.PI / 3 * i), y + r * Math.sin(Math.PI / 3 * i));
    }
    ctx.closePath(); ctx.stroke();
}

// Helper: Star for Lulu
function drawStar(ctx, x, y, r, R, p) {
    ctx.beginPath();
    for (let i = 0; i < p * 2; i++) {
        const rad = i % 2 === 0 ? R : r;
        const a = Math.PI * i / p;
        ctx.lineTo(x + Math.cos(a) * rad, y + Math.sin(a) * rad);
    }
    ctx.closePath(); ctx.fill();
}

// Helper: Heart for Momo
function drawHeart(ctx, x, y, size) {
    ctx.beginPath();
    ctx.moveTo(x, y + size / 4);
    ctx.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + size / 4);
    ctx.bezierCurveTo(x - size / 2, y + size / 2, x, y + size * 0.75, x, y + size);
    ctx.bezierCurveTo(x, y + size * 0.75, x + size / 2, y + size / 2, x + size / 2, y + size / 4);
    ctx.bezierCurveTo(x + size / 2, y, x, y, x, y + size / 4);
    ctx.fill();
}

/**
 * [TENGAI STYLE] High-Impact Character Ultimate Bomb Effects (V3)
 * Inspired by classic arcade shooters (Sengoku Blade).
 */
function drawPixelBombEffectV2(ctx, x, y, radius, alpha, charId = 'toto', timer = 0) {
    ctx.save();
    const stageWidth = 1280;
    const stageHeight = 720;

    // Screen Shake Logic
    if (timer < 30) {
        const shake = 15 * (1 - timer / 30);
        ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
    }

    ctx.globalCompositeOperation = 'lighter'; // Burn/Glow effect

    if (charId === 'toto') {
        // [GIGA STINGER BUSTER] - Enhanced with core and plasma
        ctx.globalAlpha = Math.min(1, alpha * 2);
        const beamH = 180 + Math.sin(timer * 0.4) * 60;

        // Outer Plasma
        const outerGrad = ctx.createLinearGradient(0, y - beamH, 0, y + beamH);
        outerGrad.addColorStop(0, 'rgba(255, 111, 0, 0)');
        outerGrad.addColorStop(0.5, 'rgba(255, 214, 0, 0.3)');
        outerGrad.addColorStop(1, 'rgba(255, 111, 0, 0)');
        ctx.fillStyle = outerGrad;
        ctx.fillRect(0, y - beamH, stageWidth, beamH * 2);

        // Main Beam Core
        const innerGrad = ctx.createLinearGradient(0, y - beamH / 2, 0, y + beamH / 2);
        innerGrad.addColorStop(0, 'rgba(255, 255, 255, 0)');
        innerGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.9)');
        innerGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = innerGrad;
        ctx.fillRect(0, y - beamH / 2, stageWidth, beamH);

        // Crystalline Hexagons
        ctx.strokeStyle = '#FFEA00'; ctx.lineWidth = 5;
        for (let i = 0; i < 6; i++) {
            const hx = ((timer * 25) + (i * 250)) % (stageWidth + 400) - 200;
            ctx.globalAlpha = alpha * 0.6;
            drawHexagon(ctx, hx, y, 120 + Math.sin(timer * 0.1) * 30);
        }

    } else if (charId === 'lulu') {
        // [ETERNAL STARLIGHT PILLAR] - Enhanced with magic circles and constellations
        ctx.globalAlpha = alpha;

        // Outer complex magic circle
        ctx.strokeStyle = 'rgba(240, 98, 146, 0.8)'; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(stageWidth / 2, stageHeight / 2, 350, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(stageWidth / 2, stageHeight / 2, 320, 0, Math.PI * 2); ctx.stroke();

        // Rotating inner runes
        ctx.save();
        ctx.translate(stageWidth / 2, stageHeight / 2);
        ctx.rotate(timer * 0.02);
        for (let i = 0; i < 8; i++) {
            const rot = (Math.PI * 2 / 8) * i;
            ctx.fillStyle = '#F48FB1';
            ctx.font = 'bold 20px serif';
            ctx.fillText("âœ¨", Math.cos(rot) * 280, Math.sin(rot) * 280);
        }
        ctx.restore();

        // High intensity pillars
        for (let i = 0; i < 8; i++) {
            const px = (i * 180 + (timer * 3)) % stageWidth;
            const pAlpha = 0.4 + Math.sin(timer * 0.15 + i) * 0.4;
            const pGrad = ctx.createLinearGradient(px, 0, px + 120, 0);
            pGrad.addColorStop(0, 'rgba(255, 200, 255, 0)');
            pGrad.addColorStop(0.5, `rgba(255, 255, 255, ${pAlpha})`);
            pGrad.addColorStop(1, 'rgba(255, 200, 255, 0)');
            ctx.fillStyle = pGrad;
            ctx.fillRect(px, 0, 120, stageHeight);

            // Particle Storm in pillars
            for (let j = 0; j < 8; j++) {
                const py = ((timer * 15) + (j * 120)) % stageHeight;
                ctx.fillStyle = `rgba(255, 255, 255, ${pAlpha})`;
                drawStar(ctx, px + 60 + Math.sin(timer * 0.1 + j) * 30, py, 4, 15, 4);
            }
        }

    } else if (charId === 'kaka') {
        // [EARTH-SHAKER] - Enhanced with cracks and debris
        ctx.globalAlpha = alpha;

        // Screen Flash
        if (timer < 5) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(0, 0, stageWidth, stageHeight);
        }

        // Concentric Expanding Rings
        for (let i = 0; i < 3; i++) {
            ctx.strokeStyle = `rgba(141, 110, 99, ${alpha})`;
            ctx.lineWidth = 15;
            ctx.beginPath(); ctx.arc(x, y, radius * (0.5 + i * 0.25), 0, Math.PI * 2); ctx.stroke();
        }

        // Heavy Volcanic Debris
        for (let i = 0; i < 25; i++) {
            const angle = (i * Math.PI * 2 / 25) + timer * 0.08;
            const dist = timer * 30 + (i % 3) * 50;
            const rx = x + Math.cos(angle) * dist;
            const ry = y + Math.sin(angle) * dist;
            ctx.save();
            ctx.translate(rx, ry);
            ctx.rotate(timer * 0.15);
            const rockSize = 30 + (i % 5) * 10;
            ctx.fillStyle = (i % 2 === 0) ? '#4E342E' : '#212121';
            ctx.fillRect(-rockSize / 2, -rockSize / 2, rockSize, rockSize);
            // Ember particles on rocks
            ctx.fillStyle = '#FF3D00';
            ctx.fillRect(rockSize / 4, rockSize / 4, 5, 5);
            ctx.restore();
        }

    } else if (charId === 'momo') {
        // [LOVE NOVA] - Enhanced with flower petals and pulse
        ctx.globalAlpha = alpha;

        // Pulsing Core
        const coreSize = radius * (1 + Math.sin(timer * 0.2) * 0.1);
        const coreGrad = ctx.createRadialGradient(x, y, 0, x, y, coreSize);
        coreGrad.addColorStop(0, '#FFF');
        coreGrad.addColorStop(0.5, '#FF5252');
        coreGrad.addColorStop(1, 'rgba(255, 82, 82, 0)');
        ctx.fillStyle = coreGrad;
        drawHeart(ctx, x, y, coreSize);

        // Petal/Heart Storm
        for (let i = 0; i < 30; i++) {
            const rot = (timer * 0.15) + (i * Math.PI * 2 / 30);
            const dist = radius * 0.8 + Math.sin(timer * 0.1 + i) * 100;
            ctx.save();
            ctx.translate(x + Math.cos(rot) * dist, y + Math.sin(rot) * dist);
            ctx.rotate(rot + Math.PI / 2);
            ctx.fillStyle = (i % 2 === 0) ? '#F8BBD0' : '#FFEBEE';
            drawHeart(ctx, 0, 0, 20 + (i % 5) * 5);
            ctx.restore();
        }

    } else if (charId === 'pipi') {
        // [TORNADO VORTEX] - Enhanced with lightning and debris
        ctx.globalAlpha = alpha;

        const drawHurricane = (hx, hy, scale, rotSpeed) => {
            ctx.save();
            ctx.translate(hx, hy);
            ctx.scale(scale, scale);
            ctx.rotate(timer * rotSpeed);
            for (let i = 0; i < 10; i++) {
                const r = 30 + i * 20 + Math.sin(timer * 0.3 + i) * 15;
                ctx.strokeStyle = `rgba(178, 235, 242, ${0.8 - i * 0.05})`;
                ctx.lineWidth = 3 + i;
                ctx.beginPath();
                ctx.ellipse(0, 0, r, r / 4, i * 0.5, 0, Math.PI * 2);
                ctx.stroke();

                // Static lightning inside
                if (Math.random() > 0.8) {
                    ctx.strokeStyle = '#FFF';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo((Math.random() - 0.5) * r, (Math.random() - 0.5) * r);
                    ctx.stroke();
                }
            }
            ctx.restore();
        };

        drawHurricane(stageWidth / 2 + Math.cos(timer * 0.03) * 350, stageHeight / 2 + Math.sin(timer * 0.04) * 250, 1.8, 0.05);
        drawHurricane(stageWidth - 300 + Math.sin(timer * 0.05) * 150, 250, 1.2, -0.08);
        drawHurricane(300, stageHeight - 250 + Math.cos(timer * 0.02) * 200, 1.4, 0.06);

        // Debris being sucked in
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        for (let i = 0; i < 40; i++) {
            const ly = (i * 20 + timer * 25) % stageHeight;
            const lx = (Math.sin(ly * 0.01 + timer * 0.1) * 200) + stageWidth / 2;
            ctx.fillRect(lx, ly, 4, 4);
        }
    }
    ctx.restore();
}

// [Special] Safe Guard (Shield Aura)
function drawPixelSafeGuard(ctx, x, y, w, h) {
    const t = Date.now() / 1000;
    const cx = x + w / 2;
    const cy = y + h / 2;
    const radius = w * 0.8;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(t);

    // ìœ¡ê°í˜• ë°°ë¦¬ì–´
    ctx.strokeStyle = 'rgba(0, 229, 255, 0.6)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const ang = (Math.PI * 2 / 6) * i;
        const px = Math.cos(ang) * radius;
        const py = Math.sin(ang) * radius;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.stroke();

    // ë‚´ë¶€ ê´‘ì±„
    ctx.globalAlpha = 0.2 + Math.sin(t * 10) * 0.1;
    ctx.fillStyle = '#00e5ff';
    ctx.fill();

    ctx.restore();
}

// 10. Stage Branch Selection (Original line 1005+)
function drawBranchSelectionUI(ctx, CONFIG, state) {
    const cx = CONFIG.SCREEN_WIDTH / 2;
    const cy = CONFIG.SCREEN_HEIGHT / 2;

    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0, 0, CONFIG.SCREEN_WIDTH, CONFIG.SCREEN_HEIGHT);

    ctx.font = 'bold 36px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText("CHOOSE YOUR PATH", cx, cy - 150);

    // Option A
    ctx.fillStyle = 'white';
    ctx.font = '24px sans-serif';
    ctx.fillText("[1] FOREST OF DAY", cx - 250, cy);

    // Option B
    ctx.fillText("[2] FOREST OF NIGHT", cx + 250, cy);

    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#aaa';
    ctx.fillText("Press 1 or 2 to select", cx, cy + 100);
    ctx.restore();
}

// ============================================================
// [New Player Characters] Lulu, Kaka, Momo, Pipi
// ============================================================

// 2. Lulu (Butterfly Speed Type) - V5 Upgrade
function drawPixelLuluV2(ctx, x, y, w, h) {
    if (drawCharImg(ctx, PLAYER_IMAGES.ch_player2, x, y, w, h)) return;

    const t = Date.now() / 1000;
    const hoverY = Math.sin(t * 10) * 3;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2 + hoverY);
    ctx.scale(-1, 1); // Face Left

    const luluGrid = [
        "      ppPPpp          ppPPpp    ",
        "    ppPPPPPPpp      ppPPPPPPpp  ",
        "   pPPPPPPPPPPp    pPPPPPPPPPPp ",
        "  pPPPPPPPPPPPPp  pPPPPPPPPPPPPp",
        " pPPPWWWWWWPPPPp  pPPPWWWWWWPPPPp",
        " pPPWWWWWWWWPPpp  ppPPWWWWWWWWPPp",
        " pPPWWWWWWWWPPpp  ppPPWWWWWWWWPPp",
        " pPPPWWWWWWPPPpp  ppPPPWWWWWWPPPp",
        "  pPPPPPPPPPPppBBBBppPPPPPPPPPPp",
        "   pPPPPPPPPppBBBBBBppPPPPPPPPp ",
        "    ppPPPPppBBBBBBBBBBppPPPPpp  ",
        "      ppppBBBBFEFEFBBBBpppp     ",
        "         BBBFFFFFFFFFBBB        ",
        "        BBBFFFEEEEEFFFBBB       ",
        "        BBBFFEEEEEEEFFBBB       ",
        "       BBBFFEEEEWWEEEFFBBB      ",
        "       BBBFFEEEWWWWEEEFFBBB     ",
        "       BBBFFEEEWWWWEEEFFBBB     ",
        "       BBBFFEEEEWWEEEFFBBB      ",
        "        BBBFFEEEEEEEFFBBB       ",
        "        BBBFFFEEEEEFFFBBB       ",
        "         BBBFFFFFFFFFBBB        ",
        "          BBBFFFFFFFBBB         ",
        "          BBBBBBBBBBBBB         ",
        "         ppBBBBBBBBBBBpp        ",
        "        ppppBBBBBBBBBpppp       ",
        "       ppppBBBBBBBBBBBpppp      ",
        "      ppppBBBBBBBBBBBBBpppp     ",
        "     ppppBBBBBBBBBBBBBBBpppp    ",
        "         BBBB       BBBB        ",
        "         BBBB       BBBB        ",
        "        BBBB         BBBB       "
    ];

    const colors = {
        'p': '#F48FB1', 'P': '#E91E63', 'W': 'rgba(255,255,255,0.6)',
        'B': '#880E4F', 'F': '#FFCCBC', 'E': '#1A1A1A'
    };

    luluGrid.forEach((row, ry) => {
        row.split('').forEach((pixel, rx) => {
            if (pixel === ' ') return;
            ctx.fillStyle = colors[pixel] || pixel;
            drawRect(ctx, -w / 2 + rx * pSize, -h / 2 + ry * pSize, pSize, pSize, ctx.fillStyle);
        });
    });
    ctx.restore();
}

// 3. Kaka (Beetle Power Type) - V5 Upgrade
function drawPixelKakaV2(ctx, x, y, w, h) {
    if (drawCharImg(ctx, PLAYER_IMAGES.ch_player3, x, y, w, h, true)) return;

    const t = Date.now() / 1000;
    const hoverY = Math.sin(t * 4) * 2;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2 + hoverY);
    ctx.scale(-1, 1);

    const kakaGrid = [
        "           BBBBBBBB             ",
        "         BBggggggggBB           ",
        "       BBggggggggggggBB         ",
        "      BggggggggggggggggB        ",
        "     BggggggggggggggggggB       ",
        "    BggggggggggggggggggggB      ",
        "    BggggggggggggggggggggB      ",
        "    BggggggggggggggggggggB      ",
        "    BggggggggggggggggggggB      ",
        "   BggggggggggggggggggggggB     ",
        "   BggggggggggggggggggggggB     ",
        "   BggggggggggggggggggggggB     ",
        "  BBMMMMMMMMMMMMMMMMMMMMMMBB    ",
        "  BMMMMMMMMMMMMMMMMMMMMMMMMB    ",
        "  BMMMMMMMMMMMMMMMMMMMMMMMMB    ",
        " BBMMMMMMMMMMMMMMMMMMMMMMMMBB   ",
        " BMMMMHYYYYYHMMMMHYYYYYHMMMMB   ",
        " BMMMHYYYYYYYHM MHYYYYYYYHMMMB   ",
        " BMMMHYYYYYYYHMMMMHYYYYYYYHMMMB   ",
        " BMMMMHYYYYYHMMMMMMHYYYYYHMMMMB   ",
        " BBMMMMMMMMMMMMMMMMMMMMMMMMBB   ",
        "  BBMMMMMMMMMMMMMMMMMMMMMMBB    ",
        "  BMMMMMMMMMMMMMMMMMMMMMMMMB    ",
        "  BMMMMMMMMMMHHMMMMMMMMMMMMB    ",
        "  BMMMMMMMMHHHHHHMMMMMMMMMMB    ",
        "   BMMMMMMHHHHHHHHMMMMMMMMB     ",
        "   BBMMMMMMMMHHMMMMMMMMMMBB     ",
        "    BBMMMMMMMMMMMMMMMMMMBB      ",
        "      BBMMMMMMMMMMMMMMBB        ",
        "        BBBBBBBBBBBBBB          ",
        "       BB            BB         ",
        "      BB              BB        "
    ];

    const colors = {
        'B': '#3E2723', 'g': '#5D4037', 'M': '#3E2723',
        'H': '#8D6E63', 'Y': '#FFD54F'
    };

    kakaGrid.forEach((row, ry) => {
        row.split('').forEach((pixel, rx) => {
            if (pixel === ' ') return;
            drawRect(ctx, -w / 2 + rx * pSize, -h / 2 + ry * pSize, pSize, pSize, colors[pixel] || pixel);
        });
    });
    ctx.restore();
}

// 3. Momo (Ladybug Defense Type) - V5 Upgrade
function drawPixelMomoV2(ctx, x, y, w, h) {
    if (drawCharImg(ctx, PLAYER_IMAGES.ch_player4, x, y, w, h, true)) return;

    const t = Date.now() / 1000;
    const hoverY = Math.sin(t * 4) * 4;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2 + hoverY);
    ctx.scale(-1, 1);

    const momoGrid = [
        "         RRRRRRRRRR             ",
        "       RRRRRRRRRRRRRR           ",
        "      RRRRRRRRRRRRRRRR          ",
        "     RRRRKKKKKKKKRRRRRR         ",
        "    RRRRKKKKKKKKKRRRRRRR        ",
        "    RRRRKKKKKKKKKRRRRRRR        ",
        "    RRRRKKKKKKKKKRRRRRRR        ",
        "    RRRRRRRRRRRRRRRRRRRR        ",
        "    RRRRRRRRRRRRRRRRRRRR        ",
        "    RRRRRKKKKKKKKKRRRRRR        ",
        "    RRRRRKKKKKKKKKRRRRRR        ",
        "    RRRRRRRRRRRRRRRRRRRR        ",
        "    RRBBBBBBBBBBBBBBBBRR        ",
        "    RBBBBBBBBBBBBBBBBBBR        ",
        "   BBBBBBBBBBBBBBBBBBBBBB       ",
        "   BBBBBBBBBBBBBBBBBBBBBB       ",
        "  BBBBBBFFFFFFFBBBBBBBBBBB      ",
        "  BBBBBFFFFFFFFFBBBBBBBBBB      ",
        "  BBBBBFFE E FFE EBBBBBBBB      ",
        "  BBBBBFF E EF F EBBBBBBBB      ",
        "  BBBBBFFE E FF E EBBBBBBBB      ",
        "  BBBBBFFFFFFFFFBBBBBBBBBB      ",
        "  BBBBBBFFFFFFFBBBBBBBBBBB      ",
        "   BBBBBBBBBBBBBBBBBBBBBB       ",
        "   BBBBBBBBBBBBBBBBBBBBBB       ",
        "    BBBBBBBBBBBBBBBBBBBB        ",
        "    BBBBBBBBBBBBBBBBBBBB        ",
        "     BBBBBB    BBBBBB           ",
        "      BBBB      BBBB            ",
        "      BBBB      BBBB            ",
        "      BBBB      BBBB            "
    ];

    const colors = {
        'R': '#D32F2F', 'K': '#1A1A1A', 'B': '#212121', 'F': '#FFCCBC', 'E': '#000000'
    };

    momoGrid.forEach((row, ry) => {
        row.split('').forEach((pixel, rx) => {
            if (pixel === ' ') return;
            drawRect(ctx, -w / 2 + rx * pSize, -h / 2 + ry * pSize, pSize, pSize, colors[pixel] || pixel);
        });
    });
    ctx.restore();
}

// 4. Pipi (Dragonfly Special Type) - V5 Upgrade
function drawPixelPipiV2(ctx, x, y, w, h) {
    if (drawCharImg(ctx, PLAYER_IMAGES.ch_player5, x, y, w, h)) return;

    const t = Date.now() / 1000;
    const hoverY = Math.sin(t * 8) * 6;
    const pSize = w / 32;

    ctx.save();
    ctx.translate(x + w / 2, y + h / 2 + hoverY);
    ctx.scale(-1, 1);

    const pipiGrid = [
        "             GGGG               ",
        "           GGGGGGGG             ",
        "          GGGGEEGGGG            ",
        "          GGEEEEEEGG            ",
        "          GGEEEEEEGG            ",
        "          GGGGEEGGGG            ",
        "           GGGGGGGG             ",
        "  TTTTT      BBBB      TTTTT    ",
        " TTTTTTTT    BBBB    TTTTTTTT   ",
        "TTTTTTTTTT   BBBB   TTTTTTTTTT  ",
        " TTTTTTTT    BBBB    TTTTTTTT   ",
        "  TTTTT      BBBB      TTTTT    ",
        "             BBBB               ",
        "  TTTTT      BBBB      TTTTT    ",
        " TTTTTTTT    BBBB    TTTTTTTT   ",
        "TTTTTTTTTT   BBBB   TTTTTTTTTT  ",
        " TTTTTTTT    BBBB    TTTTTTTT   ",
        "  TTTTT      BBBB      TTTTT    ",
        "             BBBB               ",
        "             BBBB               ",
        "             BBBB               ",
        "             BBBB               ",
        "             BBBB               ",
        "             BBBB               ",
        "             BBBB               ",
        "             BBBB               ",
        "             BBBB               ",
        "            BBBBBB              ",
        "           BBBBBBBB             ",
        "           BBBBBBBB             "
    ];

    const colors = {
        'G': '#43A047', 'E': '#212121', 'B': '#1B5E20', 'T': 'rgba(129, 212, 250, 0.5)'
    };

    pipiGrid.forEach((row, ry) => {
        row.split('').forEach((pixel, rx) => {
            if (pixel === ' ') return;
            drawRect(ctx, -w / 2 + rx * pSize, -h / 2 + ry * pSize, pSize, pSize, colors[pixel] || pixel);
        });
    });
    ctx.restore();
}


// [Character Choice UI] Drawing
function drawCharacterSelectionUI(ctx, CONFIG, characters, selectedIndex) {
    ctx.save();
    // Semi-transparent overlay
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, CONFIG.SCREEN_WIDTH, CONFIG.SCREEN_HEIGHT);

    // Title
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 45px "Malgun Gothic"';
    ctx.textAlign = 'center';
    ctx.fillText('ìºë¦­í„° ì„ íƒ', CONFIG.SCREEN_WIDTH / 2, 110);

    const cardW = 200;
    const cardH = 350;
    const spacing = 35;
    const startX = (CONFIG.SCREEN_WIDTH - (cardW * 5 + spacing * 4)) / 2;

    characters.forEach((char, i) => {
        const x = startX + i * (cardW + spacing);
        const y = 190;
        const isSelected = i === selectedIndex;

        // Choice Card
        ctx.fillStyle = isSelected ? 'rgba(100, 255, 218, 0.2)' : 'rgba(255,255,255,0.05)';
        ctx.strokeStyle = isSelected ? '#64FFDA' : '#444';
        ctx.lineWidth = isSelected ? 4 : 2;

        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(x, y, cardW, cardH, 10);
        else ctx.rect(x, y, cardW, cardH);
        ctx.fill();
        ctx.stroke();

        // Character Draw
        const charX = x + cardW / 2 - 75;
        const charY = y + 40;
        if (char.id === 'toto') drawPixelTotoV5(ctx, charX, charY, 150, 150); // V5 Honey Bee Toto
        else if (char.id === 'lulu') drawPixelLuluV2(ctx, charX, charY, 150, 150);
        else if (char.id === 'kaka') drawPixelKakaV2(ctx, charX, charY, 150, 150);
        else if (char.id === 'momo') drawPixelMomoV2(ctx, charX, charY, 150, 150);
        else if (char.id === 'pipi') drawPixelPipiV2(ctx, charX, charY, 150, 150);

        // Name
        ctx.fillStyle = isSelected ? '#64FFDA' : '#fff';
        ctx.font = 'bold 24px "Malgun Gothic"';
        ctx.fillText(char.name, x + cardW / 2, y + 230);

        // Stats
        ctx.font = '16px "Malgun Gothic"';
        ctx.fillStyle = '#aaa';
        ctx.fillText(`ì†ë„: ${char.speed}`, x + cardW / 2, y + 270);
        ctx.fillText(`íŒŒì›Œ: ${char.power}`, x + cardW / 2, y + 295);
        ctx.fillText(`ë²”ìœ„: ${char.range}`, x + cardW / 2, y + 320);
    });

    // Control Hint
    ctx.fillStyle = '#64FFDA';
    ctx.font = '22px "Malgun Gothic"';
    ctx.fillText('â† â†’ ë°©í–¥í‚¤ë¡œ ì„ íƒ | SPACE ë¡œ ê²°ì •', CONFIG.SCREEN_WIDTH / 2, CONFIG.SCREEN_HEIGHT - 90);
    ctx.restore();
}

// [World Map UI] Drawing
// [World Map UI] RPG-Style Continental Drawing
function drawWorldMap(ctx, CONFIG, state) {
    ctx.save();
    // 1. Map Background (Antique Parchment Style)
    ctx.fillStyle = '#e8d5b5';
    ctx.fillRect(0, 0, CONFIG.SCREEN_WIDTH, CONFIG.SCREEN_HEIGHT);

    // Subtle Grid / Texture
    ctx.strokeStyle = 'rgba(139, 69, 19, 0.1)';
    ctx.lineWidth = 1;
    for (let i = 0; i < CONFIG.SCREEN_WIDTH; i += 80) {
        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, CONFIG.SCREEN_HEIGHT); ctx.stroke();
    }
    for (let i = 0; i < CONFIG.SCREEN_HEIGHT; i += 80) {
        ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(CONFIG.SCREEN_WIDTH, i); ctx.stroke();
    }

    // 2. Continents / Regions (Enhanced with Borders)
    const drawRegion = (x, y, w, h, color, name, decoration = 'none') => {
        // Shadow/Depth
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath(); ctx.ellipse(x + 5, y + 5, w, h, 0, 0, Math.PI * 2); ctx.fill();

        // Base
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.ellipse(x, y, w, h, 0, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 3; ctx.stroke();

        // Label Decoration
        ctx.fillStyle = '#4e342e';
        ctx.font = 'italic bold 22px "Malgun Gothic"';
        ctx.textAlign = 'center';
        ctx.fillText(name, x, y - h - 15);

        // Simple Decoration
        if (decoration === 'mountains') {
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath(); ctx.moveTo(x - 30, y); ctx.lineTo(x, y - 40); ctx.lineTo(x + 30, y); ctx.fill();
        } else if (decoration === 'waves') {
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath(); ctx.arc(x + i * 20, y, 10, 0, Math.PI); ctx.stroke();
            }
        }
    };

    drawRegion(250, 480, 220, 160, '#81c784', "VERDANT FOREST", 'mountains');
    drawRegion(600, 450, 200, 130, '#64b5f6', "AZURE OCEAN", 'waves');
    drawRegion(920, 380, 240, 180, '#ffab91', "IRON VALLEY", 'mountains');
    drawRegion(1150, 200, 160, 140, '#b2ebf2', "SKY KINGDOM");

    // 3. Map Decorations (Compass Rose)
    const cx = 150, cy = 150;
    ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(cx, cy - 40); ctx.lineTo(cx, cy + 40); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx - 40, cy); ctx.lineTo(cx + 40, cy); ctx.stroke();
    ctx.fillStyle = '#5d4037'; ctx.font = 'bold 16px Arial';
    ctx.fillText("N", cx, cy - 45); ctx.fillText("S", cx, cy + 55);
    ctx.fillText("W", cx - 50, cy + 5); ctx.fillText("E", cx + 50, cy + 5);

    // 4. Stage Node Coordinates (10 Stages) - RPG Path
    const stageNodes = [
        { x: 150, y: 580 }, { x: 280, y: 480 }, { x: 420, y: 530 }, // Forest
        { x: 580, y: 450 }, { x: 740, y: 490 }, // Ocean
        { x: 880, y: 410 }, { x: 980, y: 470 }, { x: 1080, y: 350 }, // Valley
        { x: 1160, y: 220 }, { x: 1240, y: 140 } // Sky/Space
    ];

    // 5. Draw Path Lines (Dash Style)
    ctx.setLineDash([8, 8]);
    ctx.strokeStyle = '#795548';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(stageNodes[0].x, stageNodes[0].y);
    for (let i = 1; i < stageNodes.length; i++) {
        ctx.lineTo(stageNodes[i].x, stageNodes[i].y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // 6. Draw Nodes
    stageNodes.forEach((node, i) => {
        const stageNum = i + 1;
        const isActive = stageNum <= state.currentStage;
        const isNext = stageNum === state.currentStage + 1;

        if (isNext) { // Glow for next
            ctx.shadowBlur = 20; ctx.shadowColor = '#fff';
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath(); ctx.arc(node.x, node.y, 24, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        ctx.fillStyle = isActive ? '#388e3c' : (isNext ? '#fbc02d' : '#bdbdbd');
        ctx.beginPath(); ctx.arc(node.x, node.y, 18, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
        ctx.fillText(stageNum, node.x, node.y + 5);
    });

    // 7. Map Title (Calligraphy Style Feel)
    ctx.fillStyle = '#3e2723';
    ctx.font = '900 52px "Malgun Gothic"';
    ctx.textAlign = 'left';
    ctx.fillText("MAP OF ADVENTURE", 80, 80);

    // 8. Player Icon (Mini Toto)
    const progress = state.mapProgress || 0;
    const currentIdx = state.currentStage - 1;
    const nextIdx = Math.min(state.currentStage, stageNodes.length - 1);

    if (currentIdx >= 0) {
        const start = stageNodes[currentIdx];
        const end = stageNodes[nextIdx];
        const currentX = start.x + (end.x - start.x) * progress;
        const currentY = start.y + (end.y - start.y) * progress;
        const bounceY = currentY - 35 - Math.abs(Math.sin(progress * Math.PI)) * 45;

        ctx.shadowBlur = 15; ctx.shadowColor = 'rgba(0,0,0,0.4)';
        drawPixelTotoV5(ctx, currentX - 25, bounceY - 25, 50, 50);
        ctx.shadowBlur = 0;
    }

    // 9. 'GO' BUTTON (Appears when Ready)
    if (state.isWorldMapReady) {
        const btnX = CONFIG.SCREEN_WIDTH / 2;
        const btnY = CONFIG.SCREEN_HEIGHT - 100;

        // Button Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(btnX - 145, btnY - 35, 300, 80);

        // Button Body
        ctx.fillStyle = (Date.now() % 1000 < 500) ? '#ffeb3b' : '#fbc02d';
        ctx.fillRect(btnX - 150, btnY - 40, 300, 80);
        ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 5;
        ctx.strokeRect(btnX - 150, btnY - 40, 300, 80);

        ctx.fillStyle = '#3e2723';
        ctx.font = 'bold 28px "Malgun Gothic"';
        ctx.textAlign = 'center';
        ctx.fillText("START STAGE " + (state.currentStage + 1), btnX, btnY + 10);
    }

    ctx.restore();
}

/* --- ui.js --- */



import {
    drawPixelForestV2, drawPixelTotoV5, drawPixelLuluV2, drawPixelKakaV2, drawPixelMomoV2, drawPixelPipiV2
} from './pixel_art_v2.js';
function updateLivesUI() {
    const el = document.getElementById('lives');
    if (el) el.innerText = 'â¤'.repeat(state.lives);
}
function updateBombUI() {
    const el = document.getElementById('bombs');
    if (el) el.innerText = 'ğŸ’£'.repeat(state.player.bombCount);
}
function drawTitleScreen(ctx) {
    const bg = BACKGROUND_IMAGES.bgStart;
    if (bg && bg.complete && bg.naturalWidth !== 0) {
        // Draw image keeping aspect ratio (cover style)
        const scale = Math.max(CONFIG.SCREEN_WIDTH / bg.width, CONFIG.SCREEN_HEIGHT / bg.height);
        const nw = bg.width * scale;
        const nh = bg.height * scale;
        const nx = (CONFIG.SCREEN_WIDTH - nw) / 2;
        const ny = (CONFIG.SCREEN_HEIGHT - nh) / 2;
        ctx.drawImage(bg, nx, ny, nw, nh);
    } else {
        drawPixelForestV2(ctx, CONFIG, state);
    }
    // Text handled by DOM #start-screen
}
function drawGameOverScreen(ctx) {
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, CONFIG.SCREEN_WIDTH, CONFIG.SCREEN_HEIGHT);

    ctx.font = '900 80px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ff5252';
    ctx.shadowColor = '#000';
    ctx.shadowBlur = 15;
    ctx.fillText("GAME OVER", CONFIG.SCREEN_WIDTH / 2, CONFIG.SCREEN_HEIGHT / 2 - 80);

    ctx.shadowBlur = 0;

    // Draw Buttons
    const btnW = 400;
    const btnH = 60;
    const centerX = CONFIG.SCREEN_WIDTH / 2;
    const centerY = CONFIG.SCREEN_HEIGHT / 2 + 20;

    // Continue Button
    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.strokeStyle = '#00E676';
    ctx.lineWidth = 3;
    ctx.strokeRect(centerX - btnW / 2, centerY, btnW, btnH);
    ctx.fillRect(centerX - btnW / 2, centerY, btnW, btnH);

    ctx.font = 'bold 24px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText("CONTINUE (CHANGE HERO)", centerX, centerY + 38);

    // Quit Button
    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.strokeStyle = '#ff5252';
    ctx.strokeRect(centerX - btnW / 2, centerY + 80, btnW, btnH);
    ctx.fillRect(centerX - btnW / 2, centerY + 80, btnW, btnH);

    ctx.fillStyle = '#ccc';
    ctx.fillText("QUIT TO MENU", centerX, centerY + 118);
}
function drawStageClear(ctx) {
    ctx.font = 'bold 80px sans-serif'; ctx.textAlign = 'center'; ctx.fillStyle = '#ffeb3b';
    ctx.fillText("STAGE " + state.currentStage + " CLEAR!", CONFIG.SCREEN_WIDTH / 2, CONFIG.SCREEN_HEIGHT / 2);
}

// [Character Selection UI]
function drawCharacterSelectionUI(ctx, selectedIndex) {
    ctx.save();

    // 1. Character Select Background
    if (BACKGROUND_IMAGES.bgCharSelect && BACKGROUND_IMAGES.bgCharSelect.complete) {
        ctx.drawImage(BACKGROUND_IMAGES.bgCharSelect, 0, 0, CONFIG.SCREEN_WIDTH, CONFIG.SCREEN_HEIGHT);
        // Add subtle overlay to maintain text readability
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.fillRect(0, 0, CONFIG.SCREEN_WIDTH, CONFIG.SCREEN_HEIGHT);
    } else {
        // Fallback to Dark Overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
        ctx.fillRect(0, 0, CONFIG.SCREEN_WIDTH, CONFIG.SCREEN_HEIGHT);
    }

    // 2. Title
    ctx.textAlign = 'center';
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 40px "Malgun Gothic", sans-serif';
    ctx.shadowColor = '#FF8F00';
    ctx.shadowBlur = 10;
    ctx.fillText("CHOOSE YOUR HERO", CONFIG.SCREEN_WIDTH / 2, 80);
    ctx.shadowBlur = 0; // Reset shadow

    // 3. Draw Character Cards
    const cardW = 160;
    const cardH = 240;
    const gap = 20;
    const totalW = CHARACTERS.length * cardW + (CHARACTERS.length - 1) * gap;
    const startX = (CONFIG.SCREEN_WIDTH - totalW) / 2;
    const startY = CONFIG.SCREEN_HEIGHT / 2 - cardH / 2;

    CHARACTERS.forEach((char, i) => {
        const x = startX + i * (cardW + gap);
        const y = startY;
        const isSelected = (i === selectedIndex);

        // Card Background
        ctx.fillStyle = isSelected ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.5)';
        ctx.strokeStyle = isSelected ? '#00E676' : '#546E7A';
        ctx.lineWidth = isSelected ? 4 : 2;

        // Scale effect for selected
        if (isSelected) {
            ctx.save();
            ctx.translate(x + cardW / 2, y + cardH / 2);
            ctx.scale(1.1, 1.1);
            ctx.translate(-(x + cardW / 2), -(y + cardH / 2));
        }

        ctx.fillRect(x, y, cardW, cardH);
        ctx.strokeRect(x, y, cardW, cardH);

        // Character Preview (Center of Card)
        const cx = x + cardW / 2;
        const cy = y + 80;

        // Draw Character Sprite
        if (char.id === 'toto') drawPixelTotoV5(ctx, cx - 64, cy - 64, 128, 128);
        else if (char.id === 'lulu') { if (typeof drawPixelLuluV2 === 'function') drawPixelLuluV2(ctx, cx - 64, cy - 64, 128, 128); }
        else if (char.id === 'kaka') { if (typeof drawPixelKakaV2 === 'function') drawPixelKakaV2(ctx, cx - 64, cy - 64, 128, 128); }
        else if (char.id === 'momo') { if (typeof drawPixelMomoV2 === 'function') drawPixelMomoV2(ctx, cx - 64, cy - 64, 128, 128); }
        else if (char.id === 'pipi') { if (typeof drawPixelPipiV2 === 'function') drawPixelPipiV2(ctx, cx - 64, cy - 64, 128, 128); }
        else {
            // Fallback circle
            ctx.fillStyle = char.color;
            ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI * 2); ctx.fill();
        }

        // Name
        ctx.fillStyle = isSelected ? '#fff' : '#aaa';
        ctx.font = 'bold 20px "Malgun Gothic", sans-serif';
        ctx.fillText(char.name, cx, y + 160);

        // Stats Text
        ctx.font = '14px "Malgun Gothic", sans-serif';
        ctx.fillStyle = '#ccc';
        ctx.fillText(`Speed: ${char.speed}`, cx, y + 190);
        ctx.fillText(`Power: ${char.power}`, cx, y + 210);

        if (isSelected) ctx.restore();
    });

    // 4. Instructions
    ctx.fillStyle = '#00E676';
    ctx.font = '18px "Malgun Gothic", sans-serif';
    ctx.fillText("â† / â†’  Select   |   SPACE  Confirm", CONFIG.SCREEN_WIDTH / 2, CONFIG.SCREEN_HEIGHT - 60);

    ctx.restore();
}
function startWorldMap() {
    state.isWorldMapActive = true;
    state.isWorldMapReady = false;
    state.mapProgress = 0;

    // Auto-advance map progress
    const mapInterval = setInterval(() => {
        state.mapProgress += 0.015; // Slightly slower for better feel
        if (state.mapProgress >= 1) {
            state.mapProgress = 1;
            clearInterval(mapInterval);
            state.isWorldMapReady = true;
            console.log("Map Journey Complete. Waiting for 'Go' signal.");
        }
    }, 30);
}

// ëŒ€í™” ì‹œìŠ¤í…œ
function startDialogue(stage) {
    if (!STAGE_DIALOGUES[stage]) return;
    state.currentStage = stage; // Fix: Sync state with requested stage
    state.isDialogueActive = true;
    state.dialogueIndex = 0;
    showNextDialogue();
}

// Global reference for reliable listener cleanup - REMOVED interactions
// let activeDialogueFunc = null;
function showNextDialogue() {
    const dialogues = STAGE_DIALOGUES[state.currentStage];
    const box = document.getElementById('dialogue-box');

    if (!dialogues || state.dialogueIndex >= dialogues.length) {
        state.isDialogueActive = false;
        if (box) box.classList.add('hidden');
        return;
    }
    const d = dialogues[state.dialogueIndex];
    if (box) {
        box.classList.remove('hidden');
        const charName = CHARACTERS[state.selectedCharIndex]?.name || 'ë˜ë˜';
        const displayName = (d.name === 'ë˜ë˜') ? charName : d.name;
        box.querySelector('.character-name').innerText = displayName;
        box.querySelector('.text').innerText = d.text.replace(/ë˜ë˜/g, charName);
    }
}

// Global helper for mobile controls
window.advanceDialogue = () => {
    if (!state.isDialogueActive) return false;

    // Debounce to prevent instant skipping
    const now = Date.now();
    if (now - (state.lastDialogueTime || 0) < 300) {
        return false;
    }
    state.lastDialogueTime = now;

    state.dialogueIndex++;
    showNextDialogue();
    return true;
};
function startEndingSequence(ctx) {
    console.log("Ending Sequence Started");
    sound.startBGM('ENDING'); // ì—”ë”© í…Œë§ˆ ì¬ìƒ

    // 1. ëª¨ë“  UI ìˆ¨ê¸°ê¸°
    const hud = document.getElementById('hud');
    if (hud) hud.style.display = 'none';
    const dialogueBox = document.getElementById('dialogue-box');
    if (dialogueBox) dialogueBox.classList.add('hidden');

    // 2. ìº”ë²„ìŠ¤ì— ì—”ë”© ì—°ì¶œ ê·¸ë¦¬ê¸° (Update LoopëŠ” ë©ˆì·„ìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œ ì§ì ‘ ì œì–´)
    let endingFrame = 0;

    function drawEnding() {
        endingFrame++;

        ctx.fillStyle = `rgba(255, 255, 255, ${Math.min(1, endingFrame * 0.02)})`; // í™”ì´íŠ¸ ì•„ì›ƒ
        ctx.fillRect(0, 0, CONFIG.SCREEN_WIDTH, CONFIG.SCREEN_HEIGHT);

        if (endingFrame > 120) {
            // 3. ì—”ë”© í¬ë ˆë”§ í™”ë©´ìœ¼ë¡œ ì „í™˜ (DOM ì¡°ì‘)
            showCreditsScreen();
            return;
        }
        requestAnimationFrame(drawEnding);
    }
    drawEnding();
}
function showCreditsScreen() {
    // Canvasì™€ UI ìˆ¨ê¸°ê¸°
    const canvas = document.getElementById('gameCanvas');
    if (canvas) canvas.style.display = 'none';
    const hud = document.getElementById('hud');
    if (hud) hud.style.display = 'none';
    const dialogue = document.getElementById('dialogue-box');
    if (dialogue) dialogue.style.display = 'none';

    // ê¸°ì¡´ í¬ë ˆë”§ì´ ìˆë‹¤ë©´ ì œê±°
    const oldCredit = document.getElementById('ending-credits');
    if (oldCredit) oldCredit.remove();

    const creditDiv = document.createElement('div');
    creditDiv.id = 'ending-credits';
    creditDiv.style.position = 'fixed';
    creditDiv.style.top = '0';
    creditDiv.style.left = '0';
    creditDiv.style.width = '100vw';
    creditDiv.style.height = '100vh';
    creditDiv.style.background = '#000';
    creditDiv.style.color = '#fff';
    creditDiv.style.display = 'flex';
    creditDiv.style.flexDirection = 'column';
    creditDiv.style.alignItems = 'center';
    creditDiv.style.justifyContent = 'center';
    creditDiv.style.fontFamily = "'Press Start 2P', cursive, sans-serif";
    creditDiv.style.textAlign = 'center';
    creditDiv.style.zIndex = '99999';
    creditDiv.style.overflowY = 'auto';

    const content = `
        <h1 style="color: #ffd700; font-size: 40px; margin-bottom: 50px; text-shadow: 4px 4px #e65100;">THE ADVENTURE OF TOTO</h1>
        <h2 style="color: #00e676; margin-bottom: 40px; font-size: 24px; text-transform: uppercase; letter-spacing: 2px;">Mission Accomplished</h2>
        
        <div style="font-size: 16px; line-height: 2.5; margin-bottom: 40px;">
            <p style="color: #bdbdbd; font-size: 14px; margin-bottom: 20px;">- CREDITS -</p>
            
            <div style="margin-bottom: 30px;">
                <p style="color: #fff; font-weight: bold;">[ Executive Producer ]</p>
                <p style="color: #29b6f6; font-size: 20px;">PETER (PM)</p>
            </div>

            <div style="margin-bottom: 30px;">
                <p style="color: #fff; font-weight: bold;">[ Game Design ]</p>
                <p style="color: #ba68c8; font-size: 20px;">BO (Planning Leader)</p>
            </div>

            <div style="margin-bottom: 30px;">
                <p style="color: #fff; font-weight: bold;">[ Art Direction ]</p>
                <p style="color: #ff4081; font-size: 20px;">HANSOONI (AD)</p>
            </div>

            <div style="margin-bottom: 30px;">
                <p style="color: #fff; font-weight: bold;">[ Lead Programmer ]</p>
                <p style="color: #ff9800; font-size: 20px;">TTOTTO (Tech Lead)</p>
            </div>
        </div>

        <h3 style="color: #ffff00; font-size: 22px; margin-bottom: 40px; animation: blink 1s infinite;">Thank you for playing!</h3>
        
        <button onclick="handleRestart()" 
            style="padding: 20px 40px; font-family: inherit; font-size: 18px; cursor: pointer; 
            background: #fff; color: #000; border: none; font-weight: bold; border-radius: 8px; 
            box-shadow: 0 4px 10px rgba(255,255,255,0.3); transition: transform 0.2s;">
            PLAY AGAIN
        </button>
    `;

    creditDiv.innerHTML = content;

    // ì• ë‹ˆë©”ì´ì…˜ ìŠ¤íƒ€ì¼ ì¶”ê°€
    const style = document.createElement('style');
    style.innerHTML = `
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @keyframes fadeInMove {
            from { opacity: 0; transform: translateY(50px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes blink {
            50% { opacity: 0.5; }
        }
        #ending-credits { animation: fadeInMove 1.5s ease-out; }
        #ending-credits button:hover { transform: scale(1.1); background: #fce4ec; }
    `;
    document.head.appendChild(style);

    document.body.appendChild(creditDiv);
}

/* --- renderer.js --- */

import {
    drawPixelForestV2, drawPixelTotoV2, drawPixelTotoV5, drawPixelLuluV2, drawPixelKakaV2, drawPixelMomoV2, drawPixelPipiV2,
    drawPixelWaspV2, drawPixelButterflyV2, drawPixelBeetleV2, drawPixelDroneV2, drawPixelGhostV2, drawPixelSlimeV2,
    drawPixelItemV2, drawPixelBombEffectV2, drawPixelSafeGuard,
    drawPixelBossBuzzV2, drawPixelQueenArachne, drawPixelMetalOrochi, drawPixelStormFalcon, drawPixelPhantomMoth,
    drawPixelFlameSalamander, drawPixelJunkAmalgam, drawPixelToxicChimera, drawPixelSkyFortressCore, drawPixelEmperorV,
    drawPixelTotoPortrait, drawPixelLuluPortrait, drawPixelKakaPortrait, drawPixelMomoPortrait, drawPixelPipiPortrait,
    drawPixelFairyPortrait, drawWorldMap, drawBitBee
} from './pixel_art_v2.js';
function draw(ctx, state) {
    if (state.isWorldMapActive) {
        drawWorldMap(ctx, CONFIG, state);
        return;
    }

    drawPixelForestV2(ctx, CONFIG, state);

    // Particles (Visual only)
    for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        ctx.globalAlpha = Math.max(0, p.alpha);
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.globalAlpha = 1.0;

    // Bullets with Enhanced Visuals
    state.bullets.forEach(b => {
        if (b.isChargeShot) {
            ctx.save();
            ctx.translate(b.x + b.width / 2, b.y + b.height / 2);
            if (b.type === 'BIT_BEE') drawBitBee(ctx, -b.width / 2, -b.height / 2, b.width, b.height);
            else if (b.type === 'BEE_SWARM') drawPixelTotoV5(ctx, -10, -10, 20, 20);
            else if (b.type === 'METEOR') {
                b.rotation = (b.rotation || 0) + 0.1;
                ctx.rotate(b.rotation);
                ctx.fillStyle = '#5D4037'; ctx.fillRect(-b.width / 2, -b.height / 2, b.width, b.height);
                ctx.fillStyle = '#FF7043'; ctx.fillRect(-b.width / 4, -b.height / 4, b.width / 2, b.height / 2);
            } else if (b.type === 'PRISM_LASER') {
                const pulse = Math.sin(Date.now() / 50) * 0.2 + 0.8;
                // [Optimization] ShadowBlur removed - extremely slow in Canvas 2D
                ctx.fillStyle = `rgba(244, 143, 177, ${0.4 * pulse})`;
                ctx.fillRect(-b.width / 2 - 5, -b.height / 2 - 5, b.width + 10, b.height + 10);
                ctx.fillStyle = `rgba(244, 143, 177, ${0.8 * pulse})`;
                ctx.fillRect(-b.width / 2, -b.height / 2, b.width, b.height);
                ctx.fillStyle = '#FFF'; ctx.fillRect(-b.width / 2, -5, b.width, 10);
            } else if (b.type === 'SONIC_BOOM') {
                ctx.strokeStyle = '#64FFDA'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.arc(-10, 0, b.height / 2, -Math.PI / 2, Math.PI / 2, false); ctx.stroke();
            } else if (b.type === 'LOVE_BOMB') {
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.moveTo(0, 5); ctx.bezierCurveTo(0, 0, -10, -5, -10, -10);
                ctx.bezierCurveTo(-10, -18, 0, -18, 0, -10); ctx.bezierCurveTo(0, -18, 10, -18, 10, -10);
                ctx.bezierCurveTo(10, -5, 0, 0, 0, 5); ctx.fill();
            } else if (b.type === 'SHIELD_EFFECT') {
                ctx.beginPath(); ctx.strokeStyle = '#FF5252'; ctx.lineWidth = 5;
                ctx.arc(0, 0, 110, 0, Math.PI * 2); ctx.stroke();
                ctx.globalAlpha = 0.3; ctx.fillStyle = '#FFEBEE'; ctx.fill(); ctx.globalAlpha = 1.0;
            }
            ctx.restore();
        } else {
            const charId = state.player.id;
            const bulletColor = b.color || '#fff';
            ctx.save();
            ctx.translate(b.x + b.width / 2, b.y + b.height / 2);
            if (charId === 'toto') {
                ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, -8); ctx.lineTo(-10, 8); ctx.fill();
                ctx.fillStyle = '#FFF176'; ctx.fillRect(-10, -3, 20, 6);
            } else if (charId === 'lulu') {
                ctx.fillStyle = '#F48FB1'; ctx.rotate(Date.now() / 100);
                const spikes = 5, outer = 12, inner = 6;
                ctx.beginPath();
                for (let i = 0; i < spikes * 2; i++) {
                    const r = (i % 2 === 0) ? outer : inner; const a = (Math.PI * i) / spikes;
                    ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                }
                ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill();
            } else if (charId === 'kaka') {
                ctx.rotate(Date.now() / 150); ctx.fillStyle = '#5D4037'; ctx.fillRect(-10, -10, 20, 20);
                ctx.fillStyle = '#FF7043'; ctx.fillRect(-6, -6, 12, 12);
            } else if (charId === 'momo') {
                ctx.fillStyle = '#FF5252'; ctx.beginPath();
                ctx.moveTo(0, 5); ctx.bezierCurveTo(0, 0, -10, -5, -10, -10);
                ctx.bezierCurveTo(-10, -18, 0, -18, 0, -10); ctx.bezierCurveTo(0, -18, 10, -18, 10, -10);
                ctx.bezierCurveTo(10, -5, 0, 0, 0, 5); ctx.fill();
            } else if (charId === 'pipi') {
                ctx.fillStyle = '#64FFDA'; ctx.beginPath(); ctx.arc(-5, 0, 12, -Math.PI / 2, Math.PI / 2, false);
                ctx.lineWidth = 3; ctx.strokeStyle = '#64FFDA'; ctx.stroke();
            } else {
                ctx.fillStyle = bulletColor; ctx.fillRect(-b.width / 2, -b.height / 2, b.width, b.height);
            }
            ctx.restore();
        }
    });

    state.enemies.forEach(e => {
        if (e.type === ENEMY_TYPES.SCOUT_WASP) drawPixelWaspV2(ctx, e.x, e.y, e.width, e.height);
        else if (e.type === ENEMY_TYPES.DANCING_BUTTERFLY) {
            const dy = Math.sin(Date.now() / 200) * 2; drawPixelButterflyV2(ctx, e.x, e.y + dy, e.width, e.height);
        }
        else if (e.type === ENEMY_TYPES.BEETLE) drawPixelBeetleV2(ctx, e.x, e.y, e.width, e.height);
        else if (e.type === ENEMY_TYPES.DRONE) drawPixelDroneV2(ctx, e.x, e.y, e.width, e.height);
        else if (e.type === ENEMY_TYPES.GHOST) drawPixelGhostV2(ctx, e.x, e.y, e.width, e.height);
        else if (e.type === ENEMY_TYPES.SLIME) drawPixelSlimeV2(ctx, e.x, e.y, e.width, e.height);
    });

    state.enemyBullets.forEach(eb => {
        ctx.fillStyle = eb.color;
        ctx.fillRect(eb.x, eb.y, eb.width, eb.height);
        // [Optimization] ShadowBlur removed for performance
    });
    state.items.forEach(it => drawPixelItemV2(ctx, it.x, it.y, it.type));
    state.bombs.forEach(b => drawPixelBombEffectV2(ctx, b.x, b.y, b.radius, b.alpha, b.charId, b.timer));

    if (state.boss) {
        const b = state.boss;
        if (b.type === 1) drawPixelBossBuzzV2(ctx, b.x, b.y, b.width, b.height);
        else if (b.type === 2) drawPixelQueenArachne(ctx, b.x, b.y, b.width, b.height);
        else if (b.type === 3) drawPixelMetalOrochi(ctx, b.x, b.y, b.width, b.height);
        else if (b.type === 4) drawPixelStormFalcon(ctx, b.x, b.y, b.width, b.height);
        else if (b.type === 5) drawPixelPhantomMoth(ctx, b.x, b.y, b.width, b.height);
        else if (b.type === 6) drawPixelFlameSalamander(ctx, b.x, b.y, b.width, b.height);
        else if (b.type === 7) drawPixelJunkAmalgam(ctx, b.x, b.y, b.width, b.height);
        else if (b.type === 8) drawPixelToxicChimera(ctx, b.x, b.y, b.width, b.height);
        else if (b.type === 9) drawPixelSkyFortressCore(ctx, b.x, b.y, b.width, b.height);
        else if (b.type === 10) drawPixelEmperorV(ctx, b.x, b.y, b.width, b.height);
        else drawPixelBossBuzzV2(ctx, b.x, b.y, b.width, b.height);

        const hpBarW = 400; const currentW = (b.hp / b.maxHp) * hpBarW;
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(CONFIG.SCREEN_WIDTH / 2 - hpBarW / 2, 40, hpBarW, 10);
        ctx.fillStyle = '#ff5252'; ctx.fillRect(CONFIG.SCREEN_WIDTH / 2 - hpBarW / 2, 40, currentW, 10);
    }

    let shouldDrawPlayer = true;
    if (state.player.invincible) {
        if (state.player.invincibleTime % 10 < 5) shouldDrawPlayer = false;
        drawPixelSafeGuard(ctx, state.player.x, state.player.y, state.player.width, state.player.height);
    }

    if (state.player.chargeValue > 15) {
        const ratio = Math.min(1, state.player.chargeValue / state.player.maxChargeValue);
        ctx.save();
        ctx.translate(state.player.x + state.player.width / 2, state.player.y + state.player.height / 2);
        ctx.beginPath(); ctx.arc(0, 0, (state.player.width * 0.9) * ratio, 0, Math.PI * 2);
        ctx.strokeStyle = ratio === 1 ? '#00e676' : '#fff'; ctx.lineWidth = 3; ctx.stroke();
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-30, 40, 60, 6);
        ctx.fillStyle = ratio === 1 ? '#00e676' : '#fff'; ctx.fillRect(-30, 40, 60 * ratio, 6);
        if (ratio === 1) {
            for (let i = 0; i < 4; i++) {
                const angle = (Date.now() / 100) + (i * Math.PI / 2);
                ctx.fillRect(Math.cos(angle) * 35, Math.sin(angle) * 35, 5, 5);
            }
        }
        ctx.restore();
    }

    if (shouldDrawPlayer) {
        // Always verify function existence before call? Just call safely.
        // Assuming imports handle V2 mapping.
        if (state.player.id === 'toto') drawPixelTotoV5(ctx, state.player.x, state.player.y, state.player.width, state.player.height, state.player.vy);
        else if (state.player.id === 'lulu') drawPixelLuluV2(ctx, state.player.x, state.player.y, state.player.width, state.player.height, state.player.vy);
        else if (state.player.id === 'kaka') drawPixelKakaV2(ctx, state.player.x, state.player.y, state.player.width, state.player.height, state.player.vy);
        else if (state.player.id === 'momo') drawPixelMomoV2(ctx, state.player.x, state.player.y, state.player.width, state.player.height, state.player.vy);
        else if (state.player.id === 'pipi') drawPixelPipiV2(ctx, state.player.x, state.player.y, state.player.width, state.player.height, state.player.vy);
    }

    if (state.isDialogueActive) {
        const dialogues = STAGE_DIALOGUES[state.currentStage];
        const d = (dialogues && dialogues[state.dialogueIndex]);
        if (d) {
            if (d.name === 'ë˜ë˜' || d.name === CHARACTERS[state.selectedCharIndex].name) {
                const charId = state.player.id;
                if (charId === 'toto') drawPixelTotoPortrait(ctx, 200, CONFIG.SCREEN_HEIGHT - 250, 180);
                else if (charId === 'lulu') drawPixelLuluPortrait(ctx, 200, CONFIG.SCREEN_HEIGHT - 250, 180);
                else if (charId === 'kaka') drawPixelKakaPortrait(ctx, 200, CONFIG.SCREEN_HEIGHT - 250, 180);
                else if (charId === 'momo') drawPixelMomoPortrait(ctx, 200, CONFIG.SCREEN_HEIGHT - 250, 180);
                else if (charId === 'pipi') drawPixelPipiPortrait(ctx, 200, CONFIG.SCREEN_HEIGHT - 250, 180);
            } else if (d.name === 'ìš”ì •') {
                drawPixelFairyPortrait(ctx, CONFIG.SCREEN_WIDTH - 200, CONFIG.SCREEN_HEIGHT - 250, 180);
            }
        }
    }
}

/* --- entities.js --- */
function updateBackground() {
    state.bgOffset = (state.bgOffset || 0) - 2.5; // Smooth constant scroll
}
function updatePlayer() {
    let dx = 0;
    let dy = 0;
    if (state.keys['ArrowUp'] || state.keys['KeyW']) dy -= 1;
    if (state.keys['ArrowDown'] || state.keys['KeyS']) dy += 1;
    if (state.keys['ArrowLeft'] || state.keys['KeyA']) dx -= 1;
    if (state.keys['ArrowRight'] || state.keys['KeyD']) dx += 1;

    if (dx !== 0 && dy !== 0) {
        const mag = Math.sqrt(dx * dx + dy * dy);
        dx /= mag;
        dy /= mag;
    }

    const charSpeed = CHARACTERS[state.selectedCharIndex]?.speed || 5.0;
    state.player.x += dx * CONFIG.PLAYER_SPEED * (charSpeed / 5.0);
    state.player.y += dy * CONFIG.PLAYER_SPEED * (charSpeed / 5.0);
    state.player.vy = dy * CONFIG.PLAYER_SPEED * (charSpeed / 5.0);

    state.player.x = Math.max(0, Math.min(CONFIG.SCREEN_WIDTH - state.player.width, state.player.x));
    state.player.y = Math.max(0, Math.min(CONFIG.SCREEN_HEIGHT - state.player.height, state.player.y));

    if (state.player.invincible) {
        state.player.invincibleTime--;
        if (state.player.invincibleTime <= 0) {
            state.player.invincible = false;
        }
    }

    if (state.keys['Space']) {
        const now = Date.now();
        state.player.chargeValue++;

        if (state.player.chargeValue < 15) {
            if (now - state.player.lastShotTime > state.player.shotDelay) {
                shoot();
                state.player.lastShotTime = now;
            }
        }
    } else {
        if (state.player.chargeValue >= state.player.maxChargeValue) {
            fireCharacterChargeShot();
        }
        state.player.chargeValue = 0;
    }

    if (state.keys['KeyX'] || state.keys['KeyB']) {
        useBomb();
        state.keys['KeyX'] = false;
        state.keys['KeyB'] = false;
    }
}
function shoot() {
    const p = state.player;
    // Scale factor ~0.77 (192 -> 148)
    let bulletData = { speed: 14, width: 25, height: 7, color: '#fff', vx: 14, vy: 0, damage: 1 };

    if (p.id === 'kaka') {
        bulletData.width = 27; bulletData.height = 9; bulletData.damage = 2; bulletData.color = '#FFD54F';
    } else if (p.id === 'lulu') {
        bulletData.speed = 18; bulletData.vx = 18; bulletData.color = '#F06292';
    } else if (p.id === 'pipi') {
        bulletData.color = '#81C784';
    } else if (p.id === 'momo') {
        bulletData.color = '#D32F2F'; bulletData.width = 22;
    }

    switch (p.powerLevel) {
        case 1:
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 - 7 });
            break;
        case 2:
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 - 28 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 + 14 });
            break;
        case 3:
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 - 42 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 - 7 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 + 28 });
            break;
        case 4:
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 - 46, vy: -1.5 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 - 18 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 + 5 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 + 32, vy: 1.5 });
            break;
        case 5:
            const heavyBullet = { ...bulletData, width: 34, height: 12, color: '#00e676' };
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 - 58, vy: -3.5 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 - 35, vy: -1.5 });
            state.bullets.push({ ...heavyBullet, x: p.x + p.width, y: p.y + p.height / 2 - 12 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 + 12, vy: 1.5 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 + 35, vy: 3.5 });
            state.bullets.push({ ...bulletData, x: p.x + p.width, y: p.y + p.height / 2 + 35, vy: 3.5 });
            break;
    }
    sound.playShot(p.id);
}
function fireCharacterChargeShot() {
    const p = state.player;
    const charId = p.id;
    const level = Math.min(p.powerLevel, 5);

    // Scale ~0.77
    if (charId === 'toto') {
        const beeCount = 4 + (level * 2);
        for (let i = 0; i < beeCount; i++) {
            state.bullets.push({
                x: p.x + p.width / 2, y: p.y + p.height / 2,
                width: 37, height: 37, speed: 8 + Math.random() * 4,
                vx: 2 + Math.random() * 5, vy: (Math.random() - 0.5) * 8,
                color: '#FFD700', isChargeShot: true,
                type: 'BIT_BEE', homing: true, damage: 10 + level * 2,
                hp: 5 + level,
                timer: 0, lifeTime: 300 + level * 60,
                target: null
            });
        }
    } else if (charId === 'lulu') {
        state.bullets.push({
            x: p.x + p.width, y: p.y + p.height / 2, width: CONFIG.SCREEN_WIDTH, height: 35 + (level * 11),
            speed: 50, color: '#F48FB1', isChargeShot: true, type: 'PRISM_LASER', damage: 2 + level,
            duration: 60 + (level * 10), hp: 9999
        });
    } else if (charId === 'kaka') {
        const rockSize = 69 + (level * 28);
        state.bullets.push({
            x: p.x + p.width, y: p.y + p.height / 2 - rockSize / 2, width: rockSize, height: rockSize,
            speed: 8, color: '#5D4037', isChargeShot: true, type: 'METEOR', damage: 50 + (level * 20),
            pierce: true, rotation: 0, hp: 999
        });
    } else if (charId === 'momo') {
        state.player.invincible = true;
        state.player.invincibleTime = 120 + (level * 30);
        state.bullets.push({ x: p.x, y: p.y, width: 0, height: 0, type: 'SHIELD_EFFECT', duration: 60, isChargeShot: true });
        const heartCount = 4 + level * 2;
        for (let i = 0; i < heartCount; i++) {
            const angle = (Math.PI * 2 / heartCount) * i;
            state.bullets.push({
                x: p.x + p.width / 2, y: p.y + p.height / 2, vx: Math.cos(angle) * 15, vy: Math.sin(angle) * 15,
                width: 35, height: 35, color: '#FF5252', isChargeShot: true, type: 'LOVE_BOMB', damage: 20 + level * 5
            });
        }
    } else if (charId === 'pipi') {
        const boomHeight = 450 + (level * 75);
        state.bullets.push({
            x: p.x + p.width, y: p.y + p.height / 2 - boomHeight / 2,
            width: 180, height: boomHeight, speed: 35,
            color: '#64FFDA', isChargeShot: true, type: 'SONIC_BOOM',
            damage: 20 + (level * 5), hp: 999
        });
    }
    sound.playChargeShot(charId);
}
function spawnItem(x, y) {
    const rand = Math.random();
    let type = null;
    if (rand < 0.25) type = 'P';
    else if (rand < 0.35) type = 'B';
    if (type) {
        state.items.push({ x, y, startY: y, type, vx: -2, time: 0, width: 40, height: 40 });
    }
}
function updateItems() {
    for (let i = state.items.length - 1; i >= 0; i--) {
        const item = state.items[i];
        item.time++;
        item.x += item.vx;
        // [Optimization] Fix jitter: use fixed oscillation around startY instead of additive drift
        item.y = item.startY + Math.sin(item.time * 0.05) * 15;

        const p = state.player;
        if (p.x < item.x + item.width && p.x + p.width > item.x &&
            p.y < item.y + item.height && p.y + p.height > item.y) {

            if (item.type === 'P') {
                if (p.powerLevel < 5) {
                    p.powerLevel++;
                    state.score += 500;
                    sound.playPowerUp();
                } else {
                    // [Planning] Max Power Bonus: 2,000 pts
                    state.score += 2000;
                    sound.playItemGet();
                }
            } else if (item.type === 'B') {
                if (p.bombCount < 5) {
                    p.bombCount++;
                    updateBombUI();
                    sound.playItemGet();
                } else {
                    // [Planning] Max Bomb Bonus: 5,000 pts
                    state.score += 5000;
                    sound.playItemGet();
                }
            }
            document.getElementById('score').innerText = state.score.toString().padStart(6, '0');
            state.items.splice(i, 1);
            continue;
        }
        if (item.x < -100) state.items.splice(i, 1);
    }
}
function useBomb() {
    if (state.player.bombCount <= 0) return;
    state.player.bombCount--;
    updateBombUI();
    state.bombs.push({
        x: state.player.x + state.player.width / 2,
        y: state.player.y + state.player.height / 2,
        radius: 0, maxRadius: 800, alpha: 1.0, timer: 0,
        charId: state.player.id // Store player id for effect
    });
    sound.playExplosion();
}
function updateBombs() {
    for (let i = state.bombs.length - 1; i >= 0; i--) {
        const b = state.bombs[i];
        b.radius += 20; b.alpha -= 0.02; b.timer++;
        for (let j = state.enemies.length - 1; j >= 0; j--) {
            const en = state.enemies[j];
            const dx = en.x - b.x; const dy = en.y - b.y;
            if (Math.sqrt(dx * dx + dy * dy) < b.radius) {
                state.score += 100;
                createExplosion(en.x + en.width / 2, en.y + en.height / 2, '#ff4444');
                state.enemies.splice(j, 1);
            }
        }
        state.enemyBullets = state.enemyBullets.filter(eb => {
            const dx = eb.x - b.x; const dy = eb.y - b.y;
            return Math.sqrt(dx * dx + dy * dy) > b.radius;
        });
        if (state.boss) {
            const dx = state.boss.x - b.x; const dy = state.boss.y - b.y;
            if (Math.sqrt(dx * dx + dy * dy) < b.radius && b.timer % 5 === 0) {
                state.boss.hp -= 0.5;
            }
        }
        if (b.alpha <= 0) state.bombs.splice(i, 1);
    }
}
function updateBullets() {
    for (let i = state.bullets.length - 1; i >= 0; i--) {
        const b = state.bullets[i];

        if (b.homing) {
            // Find target if none
            const isTargetAlive = (b.target === state.boss && state.boss && state.boss.hp > 0) || (state.enemies.includes(b.target) && b.target.hp > 0);
            if (!b.target || !isTargetAlive) {
                let minDistSq = 1000000; // Squared distance to avoid Math.sqrt
                let nearest = null;
                state.enemies.forEach(en => {
                    const d2 = (en.x - b.x) ** 2 + (en.y - b.y) ** 2;
                    if (d2 < minDistSq) { minDistSq = d2; nearest = en; }
                });
                if (state.boss) { nearest = state.boss; } // Boss priority
                b.target = nearest;
            }

            if (b.target) {
                const tx = b.target.x + b.target.width / 2;
                const ty = b.target.y + b.target.height / 2;
                const dx = tx - b.x;
                const dy = ty - b.y;
                const angle = Math.atan2(dy, dx);

                // Adaptive steering (Bit Bee Agility)
                const targetVx = Math.cos(angle) * b.speed * 1.8;
                const targetVy = Math.sin(angle) * b.speed * 1.8;

                b.vx = (b.vx || 0) * 0.82 + targetVx * 0.18;
                b.vy = (b.vy || 0) * 0.82 + targetVy * 0.18;
            } else {
                b.vx = (b.vx || b.speed) * 0.95 + 1.0; // Cruise forward
                b.vy = (b.vy || 0) * 0.95;
            }
        }

        b.x += b.vx || b.speed;
        b.y += b.vy || 0;

        if (b.type === 'BIT_BEE') {
            b.timer++;
            if (b.timer > b.lifeTime) {
                state.bullets.splice(i, 1);
                continue;
            }
        }

        if (b.x > CONFIG.SCREEN_WIDTH + 200 || b.x < -200 || b.y < -100 || b.y > CONFIG.SCREEN_HEIGHT + 100) {
            state.bullets.splice(i, 1);
        }
    }
}
function spawnEnemy() {
    const now = Date.now();
    if (now - state.lastSpawnTime < 1500) return;
    state.lastSpawnTime = now;
    if (state.boss || state.stageCleared) return;

    const bossThreshold = state.stageStartScore + 3000;
    if (state.score >= bossThreshold && !state.boss && !state.bossSpawnedInStage) {
        state.bossSpawnedInStage = true;
        spawnBoss();
        return;
    }

    const possibleTypes = STAGE_ENEMIES[state.currentStage] || [ENEMY_TYPES.SCOUT_WASP];
    const type = possibleTypes[Math.floor(Math.random() * possibleTypes.length)];

    let w = 48, h = 48, hp = 1, speedBase = 2.0;

    if (type === ENEMY_TYPES.SCOUT_WASP) { w = 64; h = 48; hp = 2; speedBase = 2.2; }
    else if (type === ENEMY_TYPES.DANCING_BUTTERFLY) { w = 64; h = 64; hp = 1; speedBase = 1.8; }
    else if (type === ENEMY_TYPES.BEETLE) { w = 60; h = 60; hp = 4; speedBase = 1.2; }
    else if (type === ENEMY_TYPES.DRONE) { w = 60; h = 60; hp = 3; speedBase = 2.5; }
    else if (type === ENEMY_TYPES.GHOST) { w = 64; h = 64; hp = 2; speedBase = 1.5; }
    else if (type === ENEMY_TYPES.SLIME) { w = 60; h = 60; hp = 3; speedBase = 1.0; }

    const enemy = {
        type: type,
        x: CONFIG.SCREEN_WIDTH + 60,
        y: Math.random() * (CONFIG.SCREEN_HEIGHT - 120) + 60,
        speed: speedBase * (CONFIG.GAME_SPEED / 1.5),
        width: w, height: h, hp: hp, time: 0
    };
    state.enemies.push(enemy);
}
function spawnBoss() {
    const stage = state.currentStage;
    let bossData = BOSS_DATA[stage];
    if (!bossData) bossData = BOSS_DATA[1]; // Fallback

    state.boss = {
        ...bossData,
        x: CONFIG.SCREEN_WIDTH + 100,
        y: CONFIG.SCREEN_HEIGHT / 2 - 50,
        state: 'ENTERING',
        timer: 0,
        hitTimer: 0,
        phase: 1
    };
}
function updateBoss() {
    const b = state.boss;
    if (!b) return;
    b.timer++;
    if (b.hitTimer > 0) b.hitTimer--;

    if (b.state === 'ENTERING') {
        b.x -= 3;
        const entryThreshold = CONFIG.SCREEN_WIDTH - b.width - 50;
        if (b.x <= entryThreshold) b.state = 'BATTLE';
    } else if (b.state === 'BATTLE') {
        b.y += Math.sin(b.timer * 0.05) * 2;
        if (b.type === 1) {
            if (b.timer % 120 === 0) bossShoot(b);
            if (b.timer % 400 === 0) { b.state = 'DASH_PREP'; b.prepTimer = 60; }
        } else if (b.type === 2) {
            b.y = (CONFIG.SCREEN_HEIGHT / 2 - 50) + Math.sin(b.timer * 0.02) * 150;
            if (b.timer % 90 === 0) bossShoot(b);
            if (b.timer % 500 === 0) { b.state = 'WEB_ATTACK'; b.prepTimer = 100; }
        } else if (b.type === 3) {
            const centerX = CONFIG.SCREEN_WIDTH - b.width - 50;
            const centerY = CONFIG.SCREEN_HEIGHT / 2 - b.height / 2;
            b.x = centerX + Math.cos(b.timer * 0.03) * 100;
            b.y = centerY + Math.sin(b.timer * 0.04) * 150;
            if (b.timer % 60 === 0) bossShoot(b);
        } else if (b.type === 4) {
            b.x -= 5;
            if (b.x < -b.width) b.x = CONFIG.SCREEN_WIDTH;
            b.y = (CONFIG.SCREEN_HEIGHT / 2 - b.height / 2) + Math.sin(b.timer * 0.1) * 250;
            if (b.timer % 40 === 0) bossShoot(b);
        } else if (b.type === 5) {
            b.y = (CONFIG.SCREEN_HEIGHT / 2 - b.height / 2) + Math.cos(b.timer * 0.05) * 150;
            if (b.timer % 120 === 0) bossShoot(b);
        } else if (b.type === 6) {
            b.y = CONFIG.SCREEN_HEIGHT - b.height - 20;
            const centerX = CONFIG.SCREEN_WIDTH - b.width - 100;
            b.x = centerX + Math.sin(b.timer * 0.02) * 150;
            if (b.timer % 90 === 0) bossShoot(b);
        } else if (b.type === 7) {
            b.x -= 0.3;
            b.y = (CONFIG.SCREEN_HEIGHT / 2 - b.height / 2) + Math.sin(b.timer * 0.03) * 100;
            if (b.timer % 80 === 0) bossShoot(b);
        } else if (b.type === 8) {
            const targetX = CONFIG.SCREEN_WIDTH - b.width - 100;
            const corners = [{ x: targetX, y: 100 }, { x: targetX, y: CONFIG.SCREEN_HEIGHT - b.height - 100 }];
            const target = corners[Math.floor((b.timer / 300) % 2)];
            b.x += (target.x - b.x) * 0.02;
            b.y += (target.y - b.y) * 0.02;
            if (b.timer % 70 === 0) bossShoot(b);
        } else if (b.type === 9) {
            b.x = CONFIG.SCREEN_WIDTH - b.width - 50;
            b.y = CONFIG.SCREEN_HEIGHT / 2 - b.height / 2 + (Math.random() - 0.5) * 10;
            if (b.timer % 50 === 0) bossShoot(b);
        } else if (b.type === 10) { // Emperor V
            // Logic kept simple for brevity as per original
            if (b.hp > b.maxHp * 0.7) { /*...*/ } // Kept in bossShoot
            if (b.timer % 60 === 0) bossShoot(b); // Added trigger for consistency
        }
    } else if (b.state === 'DASH_PREP') {
        b.prepTimer--;
        b.x += 1;
        if (b.prepTimer <= 0) { b.state = 'DASH'; b.dashTimer = 40; }
    } else if (b.state === 'DASH') {
        b.x -= 20; b.dashTimer--;
        if (b.dashTimer <= 0 || b.x < -b.width) { b.state = 'RETURN'; }
    } else if (b.state === 'RETURN') {
        b.x += 10;
        const targetX = CONFIG.SCREEN_WIDTH - b.width - 50;
        if (b.x >= targetX) { b.x = targetX; b.state = 'BATTLE'; }
    } else if (b.state === 'WEB_ATTACK') {
        b.prepTimer--;
        if (b.prepTimer % 10 === 0) bossShoot(b);
        if (b.prepTimer <= 0) b.state = 'BATTLE';
    }

    b.y = Math.max(50, Math.min(CONFIG.SCREEN_HEIGHT - b.height - 50, b.y));

    if (b.phase === 1 && b.hp <= b.maxHp * 0.5) {
        b.phase = 2;
        for (let k = 0; k < 20; k++) {
            createExplosion(b.x + Math.random() * b.width, b.y + Math.random() * b.height, '#ffeb3b');
            createExplosion(b.x + Math.random() * b.width, b.y + Math.random() * b.height, '#9e9e9e');
        }
        sound.playExplosion();
    }

    for (let i = state.bullets.length - 1; i >= 0; i--) {
        const bull = state.bullets[i];
        if (bull.x < b.x + b.width && bull.x + bull.width > b.x &&
            bull.y < b.y + b.height && bull.y + b.height > b.y) {

            if (b.hitTimer && b.hitTimer > 0) continue;
            const damage = bull.isChargeShot ? 10 : 1;
            b.hp -= damage;
            b.hitTimer = 10;

            if (!bull.isChargeShot) state.bullets.splice(i, 1);
            else {
                const hpLoss = (bull.type === 'BIT_BEE') ? 2 : 1;
                bull.hp -= hpLoss;
                if (bull.hp <= 0) state.bullets.splice(i, 1);
            }

            createExplosion(bull.x, bull.y, '#fff');

            if (b.hp <= 0) {
                state.score += 5000;
                createExplosion(b.x + b.width / 2, b.y + b.height / 2, '#ffcc00');
                if (b.type === 10) { state.gameActive = false; startEndingSequence(); return; }
                state.boss = null;
                state.stageCleared = true;
                state.stageTransitionTimer = 180;
                document.getElementById('score').innerText = state.score.toString().padStart(6, '0');
                return;
            }
        }
    }
    if (!state.player.invincible &&
        state.player.x < b.x + b.width && state.player.x + state.player.width > b.x &&
        state.player.y < b.y + b.height && state.player.y + b.height > b.y) {
        playerHit();
    }
}
function playerHit() {
    state.lives--;
    updateLivesUI();
    state.player.invincible = true;
    state.player.invincibleTime = 120;
    sound.playExplosion();
    if (state.lives <= 0) {
        state.gameActive = false;
        state.gameOver = true;
    } else {
        state.player.powerLevel = 1;
    }
}
function bossShoot(boss) {
    const b = boss || state.boss;
    if (b.type === 1) {
        for (let i = 0; i < 3; i++) {
            state.enemyBullets.push({ x: b.x, y: b.y + b.height / 2, vx: -7, vy: (i - 1) * 1.5, width: 15, height: 8, color: '#ff5252' });
        }
    } else if (b.type === 2) {
        for (let i = 0; i < 5; i++) {
            state.enemyBullets.push({ x: b.x, y: b.y + b.height / 2, vx: -5 - Math.random() * 2, vy: (i - 2) * 1.5 + (Math.random() - 0.5), width: 12, height: 12, color: '#aa00ff' });
        }
    } else if (b.type === 3) {
        state.enemyBullets.push({ x: b.x, y: b.y + b.height / 2, vx: -12, vy: 0, width: 36, height: 10, color: '#00e5ff' });
        state.enemyBullets.push({ x: b.x, y: b.y + b.height / 2, vx: -8, vy: 3, width: 24, height: 8, color: '#00e5ff' });
        state.enemyBullets.push({ x: b.x, y: b.y + b.height / 2, vx: -8, vy: -3, width: 24, height: 8, color: '#00e5ff' });
    } else if (b.type === 4) {
        for (let i = 0; i < 5; i++) {
            state.enemyBullets.push({ x: b.x, y: b.y + b.height / 2, vx: -15, vy: (Math.random() - 0.5) * 10, width: 18, height: 5, color: '#cfd8dc' });
        }
    } else if (b.type === 5) {
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            state.enemyBullets.push({ x: b.x + b.width / 2, y: b.y + b.height / 2, vx: Math.cos(angle) * 4 - 2, vy: Math.sin(angle) * 4, width: 12, height: 12, color: '#e040fb' });
        }
    } else if (b.type === 6) {
        for (let i = 0; i < 3; i++) {
            state.enemyBullets.push({ x: b.x, y: b.y + 40, vx: -6 - i, vy: (Math.random() - 0.5) * 2, width: 48, height: 12, color: '#ff3d00' });
        }
    } else if (b.type === 7) {
        for (let i = 0; i < 6; i++) {
            state.enemyBullets.push({ x: b.x + b.width / 2, y: b.y + b.height / 2, vx: (Math.random() - 0.8) * 8, vy: (Math.random() - 0.5) * 8, width: 14, height: 14, color: '#795548' });
        }
    } else if (b.type === 8) {
        for (let i = 0; i < 4; i++) {
            state.enemyBullets.push({ x: b.x + Math.random() * b.width, y: b.y + b.height, vx: -3, vy: 5 + Math.random() * 5, width: 10, height: 16, color: '#76ff03' });
        }
    } else if (b.type === 9) {
        state.enemyBullets.push({ x: b.x, y: b.y + Math.random() * b.height, vx: -5, vy: (state.player.y - (b.y + b.height / 2)) * 0.05, width: 24, height: 10, color: '#ff1744' });
        if (b.timer % 100 === 0) {
            for (let i = 0; i < 4; i++) {
                state.enemyBullets.push({ x: b.x + b.width / 2, y: b.y + b.height / 2, vx: Math.cos(Math.PI / 2 * i) * 6, vy: Math.sin(Math.PI / 2 * i) * 6, width: 60, height: 60, color: '#cfd8dc' });
            }
        }
    } else if (b.type === 10) {
        if (b.hp > b.maxHp * 0.7) {
            state.enemyBullets.push({ x: b.x, y: b.y + 40, vx: -12, vy: 0, width: 48, height: 12, color: '#ffd600' });
            state.enemyBullets.push({ x: b.x, y: b.y + 100, vx: -12, vy: 0, width: 48, height: 12, color: '#ffd600' });
        } else if (b.hp > b.maxHp * 0.3) {
            for (let i = 0; i < 3; i++) {
                state.enemyBullets.push({ x: b.x, y: b.y + b.height / 2, vx: -10 - Math.random() * 5, vy: (Math.random() - 0.5) * 10, width: 38, height: 10, color: '#e0e0e0' });
            }
        } else {
            for (let i = 0; i < 12; i++) {
                const angle = b.timer * 0.1 + (Math.PI * 2 / 12) * i;
                state.enemyBullets.push({ x: b.x + b.width / 2, y: b.y + b.height / 2, vx: Math.cos(angle) * 6, vy: Math.sin(angle) * 6, width: 12, height: 12, color: '#ff1744' });
            }
        }
    }
}
function updateEnemyBullets() {
    for (let i = state.enemyBullets.length - 1; i >= 0; i--) {
        const eb = state.enemyBullets[i];
        eb.x += eb.vx; eb.y += eb.vy;
        if (eb.x < -20 || eb.x > CONFIG.SCREEN_WIDTH + 20 || eb.y < -20 || eb.y > CONFIG.SCREEN_HEIGHT + 20) {
            state.enemyBullets.splice(i, 1);
            continue;
        }
        if (!state.player.invincible &&
            state.player.x < eb.x + eb.width && state.player.x + state.player.width > eb.x &&
            state.player.y < eb.y + eb.height && state.player.y + state.player.height > eb.y) {
            state.enemyBullets.splice(i, 1);
            playerHit();
        }
    }
}
function updateEnemies() {
    for (let i = state.enemies.length - 1; i >= 0; i--) {
        const e = state.enemies[i];
        e.time = (e.time || 0) + 1;

        moveEnemy(e);
        enemyShootLogic(e);

        if (handleEnemyCollisions(e, i)) continue;

        // Out of bounds
        if (e.x + e.width < -150) {
            state.enemies.splice(i, 1);
        }
    }
}

function moveEnemy(e) {
    switch (e.type) {
        case ENEMY_TYPES.SCOUT_WASP:
            e.x -= e.speed;
            e.y += Math.sin(e.time * 0.1) * 2;
            break;
        case ENEMY_TYPES.DANCING_BUTTERFLY:
            e.x -= e.speed * 0.8;
            e.y += Math.sin(e.time * 0.05) * 5;
            break;
        case ENEMY_TYPES.BEETLE:
            e.x -= e.speed;
            if (Math.floor(e.time / 60) % 2 === 0) e.y += 2;
            else e.y -= 2;
            break;
        case ENEMY_TYPES.DRONE:
            e.x -= e.speed;
            const dy = state.player.y - e.y;
            if (Math.abs(dy) > 5) e.y += (dy > 0 ? 1 : -1) * 1.5;
            break;
        case ENEMY_TYPES.GHOST:
            const cycle = e.time % 120;
            if (cycle < 40) e.x -= e.speed * 3;
            else e.x -= e.speed * 0.5;
            break;
        case ENEMY_TYPES.SLIME:
            e.x -= e.speed;
            e.y += Math.sin(e.time * 0.08) * 8;
            break;
        default:
            e.x -= e.speed;
    }
}

function enemyShootLogic(e) {
    let shootInterval = 80 + (Math.random() * 40);
    if (state.currentStage > 3) shootInterval -= 20;

    if (e.time % Math.floor(shootInterval) === 0 && e.x > 100 && e.x < CONFIG.SCREEN_WIDTH) {
        enemyShoot(e);
    }
}

function handleEnemyCollisions(e, index) {
    // 1. Collision with player bullets
    for (let j = state.bullets.length - 1; j >= 0; j--) {
        const b = state.bullets[j];
        if (b.x < e.x + e.width && b.x + b.width > e.x &&
            b.y < e.y + e.height && b.y + b.height > e.y) {

            e.hp -= (b.isChargeShot ? 5 : 1);

            if (e.hp <= 0) {
                state.score += 100;
                createExplosion(e.x + e.width / 2, e.y + e.height / 2, '#ff4444');
                sound.playExplosion();
                spawnItem(e.x, e.y);
                document.getElementById('score').innerText = state.score.toString().padStart(6, '0');
                state.enemies.splice(index, 1);

                // Cleanup bullet
                if (!b.isChargeShot) state.bullets.splice(j, 1);
                return true; // Enemy destroyed
            }

            if (!b.isChargeShot) {
                state.bullets.splice(j, 1);
            } else {
                const hpLoss = (b.type === 'BIT_BEE') ? 2 : 1;
                b.hp -= hpLoss;
                if (b.hp <= 0) state.bullets.splice(j, 1);
            }
        }
    }

    // 2. Collision with player
    if (!state.player.invincible &&
        state.player.x < e.x + e.width && state.player.x + state.player.width > e.x &&
        state.player.y < e.y + e.height && state.player.y + state.player.height > e.y) {
        playerHit();
        return true; // Simple removal or handle damage
    }

    return false;
}
function enemyShoot(e) {
    // Base size increased from 10x10 -> 12x12
    const common = { x: e.x, y: e.y + e.height / 2, width: 12, height: 12, color: '#FF5252' };
    switch (e.type) {
        case ENEMY_TYPES.SCOUT_WASP:
            state.enemyBullets.push({ ...common, vx: -7, vy: 0 }); // Faster bullet
            break;
        case ENEMY_TYPES.DANCING_BUTTERFLY:
            // 5-way fan
            for (let i = -2; i <= 2; i++) {
                state.enemyBullets.push({ ...common, vx: -5, vy: i * 1.2, color: '#FF4081' });
            }
            break;
        case ENEMY_TYPES.BEETLE:
            // Heavy aimed shot (24 -> 28)
            const bdx = state.player.x - e.x;
            const bdy = state.player.y - e.y;
            const bdist = Math.sqrt(bdx * bdx + bdy * bdy);
            state.enemyBullets.push({ ...common, vx: (bdx / bdist) * 4, vy: (bdy / bdist) * 4, width: 28, height: 28, color: '#FFD54F' });
            break;
        case ENEMY_TYPES.DRONE:
            state.enemyBullets.push({ ...common, vx: -8, vy: 0, color: '#00E5FF' });
            state.enemyBullets.push({ ...common, x: e.x - 30, y: e.y + e.height / 2, vx: -8, vy: 0, color: '#00E5FF' });
            break;
        case ENEMY_TYPES.GHOST:
            // 8-way star burst
            for (let i = 0; i < 8; i++) {
                const ang = (Math.PI / 4) * i;
                state.enemyBullets.push({ ...common, vx: Math.cos(ang) * 5, vy: Math.sin(ang) * 5, color: '#E0E0E0' });
            }
            break;
        case ENEMY_TYPES.SLIME:
            // Triple spread
            for (let i = -1; i <= 1; i++) {
                state.enemyBullets.push({ ...common, vx: -3, vy: i * 3, color: '#8BC34A' });
            }
            break;
        default:
            state.enemyBullets.push({ ...common, vx: -6, vy: 0 });
    }
}
function updateParticles() {
    for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        p.x += p.vx; p.y += p.vy; p.alpha -= 0.02;
        if (p.x < -50 || p.x > CONFIG.SCREEN_WIDTH + 50 || p.y < -50 || p.y > CONFIG.SCREEN_HEIGHT + 50 || p.alpha <= 0) {
            state.particles.splice(i, 1);
        }
    }
}
function createExplosion(x, y, color) {
    const finalColor = color || '#ffffff';
    for (let i = 0; i < 10; i++) {
        state.particles.push({
            x, y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6,
            size: Math.random() * 4 + 2, color: finalColor, alpha: 1.0
        });
    }
}

/* --- cheat.js --- */

// Development Cheats
window.gameCheat = function (type) {
    const state = window.state;
    if (!state || (!state.gameActive && type !== 'nextStage')) {
        alert("ê²Œì„ ì‹œì‘ í›„ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.");
        return;
    }
    const sound = window.sound;
    const updateBombUI = window.updateBombUI;
    const startDialogue = window.startDialogue;
    const startEndingSequence = window.startEndingSequence;

    switch (type) {
        case 'killBoss':
            if (state.boss) {
                state.boss.hp = 0;
                console.log("Boss Killed by Cheat");
            } else {
                console.log("No Boss to Kill");
                state.score += 5000;
                const scoreEl = document.getElementById('score');
                if (scoreEl) scoreEl.innerText = state.score.toString().padStart(6, '0');
            }
            break;
        case 'maxPower':
            state.player.powerLevel = 5;
            if (sound) sound.playPowerUp();
            console.log("Max Power Activated");
            break;
        case 'fullBomb':
            state.player.bombCount = 99;
            if (updateBombUI) updateBombUI();
            if (sound) sound.playItemGet();
            console.log("Full Bomb Activated");
            break;
        case 'invincible':
            state.player.invincible = !state.player.invincible;
            state.player.invincibleTime = state.player.invincible ? 999999 : 0;
            console.log("God Mode: " + state.player.invincible);
            break;
        case 'nextStage':
            state.currentStage++;
            state.stageCleared = false;
            state.boss = null;
            state.bossSpawnedInStage = false;
            state.score += 10000;
            state.stageStartScore = state.score;
            const scoreEl2 = document.getElementById('score');
            if (scoreEl2) scoreEl2.innerText = state.score.toString().padStart(6, '0');
            if (startDialogue) startDialogue(state.currentStage);
            console.log("Warped to Stage " + state.currentStage);
            break;
        case 'ending':
            state.gameActive = false;
            if (startEndingSequence) startEndingSequence();
            console.log("Forced Ending Sequence");
            break;
    }
};

/* --- game.js --- */




import {
    updateBackground, updatePlayer, updateBullets, spawnEnemy, updateEnemies,
    updateBoss, updateEnemyBullets, updateItems, updateBombs, updateParticles
} from './entities.js?v=bust2';
import {
    drawTitleScreen, drawGameOverScreen, drawStageClear,
    drawCharacterSelectionUI, updateLivesUI, updateBombUI,
    startDialogue, startEndingSequence, startWorldMap
} from './ui.js';


// Expose globals for cheats
window.sound = sound;
window.updateBombUI = updateBombUI;
window.startDialogue = startDialogue;
window.startEndingSequence = startEndingSequence;
window.goNextStage = () => {
    if (state.isWorldMapActive && state.isWorldMapReady) {
        state.isWorldMapActive = false;
        state.isWorldMapReady = false;
        state.currentStage++;
        startDialogue(state.currentStage);
        sound.playConfirm();
    }
};

// [Cheat Logic] - Requested by CEO (QA Issue #5)
window.gameCheat = function (type) {
    if (!state.gameActive && type !== 'ending') return;

    switch (type) {
        case 'killBoss':
            if (state.boss) {
                state.boss.hp = 0;
                console.log("Cheat: Boss Eliminated!");
            }
            break;
        case 'maxPower':
            state.player.powerLevel = 5;
            sound.playPowerUp();
            console.log("Cheat: Max Power Level!");
            break;
        case 'fullBomb':
            state.player.bombCount = 9;
            updateBombUI();
            sound.playItemGet();
            console.log("Cheat: Bombs Refilled!");
            break;
        case 'invincible':
            state.player.invincible = true;
            state.player.invincibleTime = 999999;
            console.log("Cheat: God Mode ON!");
            break;
        case 'nextStage':
            state.stageCleared = true;
            state.stageTransitionTimer = 10;
            console.log("Cheat: Skipping Stage...");
            break;
        case 'ending':
            state.gameActive = false;
            startEndingSequence(ctx);
            console.log("Cheat: Forcing Ending Sequence...");
            break;
    }
};

window.handleRestart = () => {
    resetState();
    const credits = document.getElementById('ending-credits');
    if (credits) credits.remove();
    const canvas = document.getElementById('gameCanvas');
    if (canvas) canvas.style.display = 'block';

    // UI ë ˆì´ì–´ ì´ˆê¸°í™”
    document.getElementById('ui-layer').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');

    // UI HUD reset
    const hud = document.getElementById('hud');
    if (hud) {
        hud.style.display = 'flex';
        hud.classList.remove('hidden');
    }

    // ì‹œì‘ìŒ ì¬ìƒ
    sound.startBGM('START');

    // [Bug Fix] Interaction listener lost after restart
    window.addEventListener('click', startGame, { once: true });
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// Canvas Resize
canvas.width = CONFIG.SCREEN_WIDTH;
canvas.height = CONFIG.SCREEN_HEIGHT;

function resizeCanvas() {
    const scale = Math.min(
        window.innerWidth / CONFIG.SCREEN_WIDTH,
        window.innerHeight / CONFIG.SCREEN_HEIGHT
    );
    canvas.style.width = `${CONFIG.SCREEN_WIDTH * scale}px`;
    canvas.style.height = `${CONFIG.SCREEN_HEIGHT * scale}px`;

    const ui = document.getElementById('ui-layer');
    const startScreen = document.getElementById('start-screen');
    [ui, startScreen].forEach(el => {
        if (el) {
            el.style.width = `${CONFIG.SCREEN_WIDTH}px`;
            el.style.height = `${CONFIG.SCREEN_HEIGHT}px`;
            el.style.transform = `scale(${scale})`;
            el.style.transformOrigin = 'top left';
        }
    });
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Input Handling
window.addEventListener('keydown', (e) => {
    if (state.isSelectingCharacter) {
        if (e.key === 'ArrowRight') {
            state.selectedCharIndex = (state.selectedCharIndex + 1) % CHARACTERS.length;
            sound.playSelect();
        } else if (e.key === 'ArrowLeft') {
            state.selectedCharIndex = (state.selectedCharIndex - 1 + CHARACTERS.length) % CHARACTERS.length;
            sound.playSelect();
        } else if (e.code === 'Space' || e.code === 'Enter') {
            confirmCharacter();
        }
        return;
    }

    if (!state.gameActive && state.gameOver && e.code === 'KeyR') {
        window.handleRestart();
        return;
    }

    if (state.gameActive) {
        state.keys[e.code] = true;

        // World Map Go signal
        if (state.isWorldMapActive && state.isWorldMapReady && (e.code === 'Space' || e.code === 'Enter')) {
            window.goNextStage();
        }

        // Dialogue / Branching logic
        if (state.isDialogueActive && (e.code === 'Space' || e.code === 'Enter')) {
            window.advanceDialogue();
        }
    }
});

window.addEventListener('keyup', (e) => {
    if (state.gameActive) state.keys[e.code] = false;
});

// Fix for input stuck when window loses focus (QA Issue #1)
window.addEventListener('blur', () => {
    state.keys = {};
});

// Mobile Controls Enhancement: Sliding D-Pad ("ë„ë¡œë¡" feel)
const dPad = document.getElementById('d-pad');
const dPadButtons = document.querySelectorAll('.d-btn');

function handleDPadTouch(e) {
    if (!state.gameActive && !state.isSelectingCharacter) return;
    e.preventDefault();
    const touch = e.touches[0];
    const rect = dPad.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    // Reset current keys
    state.keys['ArrowUp'] = false;
    state.keys['ArrowDown'] = false;
    state.keys['ArrowLeft'] = false;
    state.keys['ArrowRight'] = false;

    // Determine direction based on touch position relative to center
    const centerX = rect.width / 2;
    const centerY = rect.height / 2;
    const threshold = 20;

    const up = y < centerY - threshold;
    const down = y > centerY + threshold;
    const left = x < centerX - threshold;
    const right = x > centerX + threshold;

    if (state.isSelectingCharacter) {
        handleDPadNavigation(left, right);
    } else {
        state.keys['ArrowUp'] = up;
        state.keys['ArrowDown'] = down;
        state.keys['ArrowLeft'] = left;
        state.keys['ArrowRight'] = right;
    }
}

if (dPad) {
    dPad.addEventListener('touchstart', handleDPadTouch);
    dPad.addEventListener('touchmove', handleDPadTouch);
    dPad.addEventListener('touchend', (e) => {
        state.keys['ArrowUp'] = false;
        state.keys['ArrowDown'] = false;
        state.keys['ArrowLeft'] = false;
        state.keys['ArrowRight'] = false;
    });
}

const btnShot = document.getElementById('btn-shot');
const btnBomb = document.getElementById('btn-bomb');

if (btnShot) {
    btnShot.addEventListener('touchstart', (e) => {
        e.preventDefault();

        // 1. Character Selection Confirm
        if (state.isSelectingCharacter) {
            confirmCharacter();
            return;
        }

        // 2. Advance Dialogue
        if (state.isDialogueActive) {
            window.advanceDialogue();
            return;
        }

        // 3. Gameplay Shot
        state.keys['Space'] = true;
        if (state.isWorldMapReady) window.goNextStage();
    });
    btnShot.addEventListener('touchend', (e) => { e.preventDefault(); state.keys['Space'] = false; });
}

if (btnBomb) {
    btnBomb.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (state.gameActive && !state.gameOver) {
            state.keys['KeyX'] = true;
        }
    });
    btnBomb.addEventListener('touchend', (e) => {
        e.preventDefault();
        state.keys['KeyX'] = false;
    });
}

// Logic to handle D-pad navigation for menus
let lastDPadSignal = 0;
function handleDPadNavigation(left, right) {
    if (Date.now() - lastDPadSignal < 250) return; // Debounce
    if (left) {
        state.selectedCharIndex = (state.selectedCharIndex - 1 + CHARACTERS.length) % CHARACTERS.length;
        sound.playSelect();
        lastDPadSignal = Date.now();
    } else if (right) {
        state.selectedCharIndex = (state.selectedCharIndex + 1) % CHARACTERS.length;
        sound.playSelect();
        lastDPadSignal = Date.now();
    }
}

// Global Start Logic
async function startGame() {
    // Only allow starting if we are on the title screen
    if (state.gameActive || state.isSelectingCharacter) return;

    // [Bug Fix] BGM Startup: Ensure Audio is initialized and BGM starts ASAP
    try {
        await sound.init();
        sound.startBGM('START');
        sound.playConfirm();

        // [New] Mobile: Try to lock orientation to landscape
        if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(e => console.log("Orientation lock skipped (requires fullscreen):", e));
        }
    } catch (err) {
        console.error("Audio Init Failed:", err);
    }

    state.isTitleScreen = false;

    try {
        const startMsg = document.querySelector('.start-message');
        if (startMsg) startMsg.innerText = "LOADING ADVENTURE...";

        await Promise.all([
            loadAllAssets(),
            new Promise(resolve => setTimeout(resolve, 1500))
        ]);

        document.getElementById('start-screen').classList.add('hidden');

        // [Fix] Show UI layer for Mobile Controls (Character select needs them)
        document.getElementById('ui-layer').classList.remove('hidden');
        const hud = document.getElementById('hud');
        if (hud) hud.classList.add('hidden'); // Ensure HUD is still hidden

        state.isSelectingCharacter = true;
        state.selectedCharIndex = 0;

        // [New] Mobile Detection Fallback: If touch is detected, ensure controls are visible
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            const controls = document.getElementById('mobile-controls');
            if (controls) controls.style.display = 'block';
        }

        // Smooth transition to select music
        sound.startBGM('SELECT');

    } catch (err) {
        console.error("Asset Load Error:", err);
    }
    window.removeEventListener('click', startGame);
    window.removeEventListener('touchstart', startGame);

    // [New] Add global click listener for map 'GO' and Game Over Restart
    const handleGlobalAction = (e) => {
        // [Optimization] If it's a touch on a control button, don't trigger global action
        if (e.target.closest('.control-group')) return;

        if (state.isWorldMapActive && state.isWorldMapReady && (e.code === 'Space' || e.code === 'Enter')) {
            window.goNextStage();
        }
        if (state.isSelectingCharacter) {
            // Character Card Click Logic
            const rect = canvas.getBoundingClientRect();
            const scaleX = CONFIG.SCREEN_WIDTH / rect.width;
            const scaleY = CONFIG.SCREEN_HEIGHT / rect.height;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            const cardW = 160;
            const cardH = 240;
            const gap = 20;
            const totalW = CHARACTERS.length * cardW + (CHARACTERS.length - 1) * gap;
            const startX = (CONFIG.SCREEN_WIDTH - totalW) / 2;
            const startY = CONFIG.SCREEN_HEIGHT / 2 - cardH / 2;

            for (let i = 0; i < CHARACTERS.length; i++) {
                const x = startX + i * (cardW + gap);
                const y = startY;

                if (canvasX >= x && canvasX <= x + cardW &&
                    canvasY >= y && canvasY <= y + cardH) {

                    if (state.selectedCharIndex === i) {
                        // Confirm if clicked again
                        confirmCharacter();
                    } else {
                        // Select
                        state.selectedCharIndex = i;
                        sound.playSelect();
                    }
                    return;
                }
            }
        }


        // [New] Dialogue Advance Logic (Centralized)
        if (state.isDialogueActive) {
            window.advanceDialogue();
            return;
        }

        if (state.gameOver) {
            // Check button clicks on Game Over screen
            const rect = canvas.getBoundingClientRect();
            const scaleX = CONFIG.SCREEN_WIDTH / rect.width;
            const scaleY = CONFIG.SCREEN_HEIGHT / rect.height;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            const btnW = 400;
            const btnH = 60;
            const centerX = CONFIG.SCREEN_WIDTH / 2;
            const centerY = CONFIG.SCREEN_HEIGHT / 2 + 20;

            // 1. Continue Button (Character Select)
            if (canvasX >= centerX - btnW / 2 && canvasX <= centerX + btnW / 2 &&
                canvasY >= centerY && canvasY <= centerY + btnH) {
                state.isContinuing = true;
                state.gameOver = false;
                state.isSelectingCharacter = true;
                sound.playConfirm();
                sound.startBGM('SELECT');
                return;
            }

            // 2. Quit Button
            if (canvasX >= centerX - btnW / 2 && canvasX <= centerX + btnW / 2 &&
                canvasY >= centerY + 80 && canvasY <= centerY + 80 + btnH) {
                window.handleRestart();
                return;
            }
        }
    };
    window.addEventListener('click', handleGlobalAction);
    window.addEventListener('touchstart', handleGlobalAction);
}

window.startGame = startGame;
window.addEventListener('click', startGame, { once: true });
window.addEventListener('touchstart', startGame, { once: true });
window.addEventListener('keydown', (e) => {
    if (!state.gameActive && !state.isSelectingCharacter && (e.code === 'Space' || e.code === 'Enter')) {
        startGame();
    }
});

function confirmCharacter() {
    if (state.gameActive && !state.isContinuing) return;

    const isCont = state.isContinuing;
    state.isSelectingCharacter = false;
    state.gameActive = true;
    state.gameOver = false;
    state.isContinuing = false;

    // Apply Character Stats
    const char = CHARACTERS[state.selectedCharIndex];
    state.player.color = char.color;
    state.player.id = char.id;
    state.player.shotDelay = char.shotDelay;

    // Character Specific Stats update (Size/Speed)
    state.player.width = 148;
    state.player.height = 148;

    // UI Update
    document.getElementById('ui-layer').classList.remove('hidden');
    const hud = document.getElementById('hud');
    if (hud) hud.classList.remove('hidden');

    if (isCont) {
        // Continue Logic: Reset basic stats but keep stage/score
        state.lives = 3;
        state.player.bombCount = 3;
        state.player.powerLevel = 1; // Penalty for dying
        state.player.invincible = true;
        state.player.invincibleTime = 120;
        state.player.x = 100;
        state.player.y = 300;
        state.enemies = []; // Clear current enemies for fair resume
        state.enemyBullets = [];
        updateLivesUI();
        updateBombUI();
        sound.playConfirm();
        sound.startBGM(`STAGE_${state.currentStage}`);
    } else {
        // Fresh start
        updateLivesUI();
        updateBombUI();
        sound.playGameStart();
        sound.startBGM(`STAGE_${state.currentStage}`);
        startDialogue(state.currentStage);
    }
}

// Game Loop
function gameLoop() {
    try {
        if (state.isSelectingCharacter) {
            drawCharacterSelectionUI(ctx, state.selectedCharIndex);
        } else if (state.gameActive && !state.gameOver) {

            if (state.stageCleared) {
                drawStageClear(ctx);
                state.stageTransitionTimer--;
                if (state.stageTransitionTimer <= 0) {
                    state.stageCleared = false;
                    state.stageTransitionTimer = 0;
                    state.boss = null;
                    state.bossSpawnedInStage = false;
                    state.enemies = [];
                    state.bullets = [];
                    state.enemyBullets = [];
                    state.stageStartScore = state.score;
                    state.player.x = 100; state.player.y = 300; // Reset Pos
                    sound.startBGM(`STAGE_${state.currentStage + 1}`); // Preview next stage music
                    startWorldMap(); // Fixed: Show world map instead of skipping to dialogue
                }
            } else if (!state.isDialogueActive && !state.isWorldMapActive) {
                updateBackground(); // Smooth scroll update
                updatePlayer();
                updateBullets();
                spawnEnemy();
                updateEnemies();
                updateBoss();
                updateEnemyBullets();
                updateItems();
                updateBombs();
                updateParticles();

                // Drawing
                draw(ctx, state);
            } else {
                // Dialogue or Map active: Just draw current state (paused)
                draw(ctx, state);
            }

        } else if (state.gameOver) {
            draw(ctx, state);
            drawGameOverScreen(ctx);
        } else {
            // Title Screen
            drawTitleScreen(ctx);
        }
    } catch (err) {
        console.error("Game Loop Error:", err);
    }
    requestAnimationFrame(gameLoop);
}

// Start Loop
requestAnimationFrame(gameLoop);

</script>
</body>

</html>